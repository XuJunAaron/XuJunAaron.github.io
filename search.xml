<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/11/11/Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/11/11/Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis高性能IO模型"><a href="#Redis高性能IO模型" class="headerlink" title="Redis高性能IO模型"></a>Redis高性能IO模型</h3><h4 id="关于Redis单线程"><a href="#关于Redis单线程" class="headerlink" title="关于Redis单线程"></a>关于Redis单线程</h4><p>Redis的网络IO和键值对读写都是由一个线程来完成的，这也是Redis对外提供键值服务的主要流程。但Redis的其他功能，比如：持久化、异步删除、集群数据同步等功能都需要额外的线程去完成。</p><h4 id="为什么Redis要使用单线程"><a href="#为什么Redis要使用单线程" class="headerlink" title="为什么Redis要使用单线程"></a>为什么Redis要使用单线程</h4><p>多线程下会有<strong>共享资源并发访问控制</strong>问题，会给系统带来额外的开销，从而无法提高系统的吞吐率。</p><h4 id="基本IO模型"><a href="#基本IO模型" class="headerlink" title="基本IO模型"></a>基本IO模型</h4><p>以 Get 请求为例，SimpleKV 为了处理一个 Get 请求，需要监听客户端请求（bind&#x2F;listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p><p><a href="https://imgtu.com/i/jsidZF"><img src="https://s1.ax1x.com/2022/07/10/jsidZF.md.jpg" alt="jsidZF.md.jpg"></a></p><p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p><h4 id="基于多路复用的Redis-IO模型"><a href="#基于多路复用的Redis-IO模型" class="headerlink" title="基于多路复用的Redis IO模型"></a>基于多路复用的Redis IO模型</h4><p>Linux系统中的IO多路复用模型是指一个线程可以处理多个IO流，即select&#x2F;epoll机制。它允许Linux内核同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字的连接请求或者数据请求，一旦有请求到达，就会交给Redis处理，这样就实现了一个Redis线程处理多个IO流的效果。</p><p>下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p><p><a href="https://imgtu.com/i/jseykT"><img src="https://s1.ax1x.com/2022/07/10/jseykT.md.jpg" alt="jseykT.md.jpg"></a></p><p>为了在请求到达时能通知到 Redis 线程，select&#x2F;epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/11/springboot/"/>
      <url>/2022/11/11/springboot/</url>
      
        <content type="html"><![CDATA[<h3 id="1-spring-boot-starter"><a href="#1-spring-boot-starter" class="headerlink" title="1. spring-boot-starter"></a>1. spring-boot-starter</h3><pre><code>决定一个项目是否为SpringBoot项目的关键是看是否集成了spring-boot-starter-parent。</code></pre><h4 id="1-1-spring-boot-starter-parent"><a href="#1-1-spring-boot-starter-parent" class="headerlink" title="1.1 spring-boot-starter-parent"></a>1.1 spring-boot-starter-parent</h4><p>spring-boot-starter-parent中提前配置好了常见第三方组件的版本号，方便直接引用，若遇到需要指定版本的场景，推荐使用如下方法指定版本：</p><ol><li>查询spring-boot-depedencies中该依赖的标签名；</li><li>在当前项目中重写该配置项。</li></ol><h4 id="1-2-starter的一些默认配置"><a href="#1-2-starter的一些默认配置" class="headerlink" title="1.2 starter的一些默认配置"></a>1.2 starter的一些默认配置</h4><pre><code>SpringBoot提供了大量的官方starter，供开发者使用，其命名方式spring-boot-starter-*，若要自定义starter，官方推荐命名为*-spring-boot-starter</code></pre><p>无论是官方starter还是第三方starter，都要依赖于spring-boot-starter，而starter的自动装配核心依赖是spring-boot-autoconfigure。<br>SpringBoot提供了大量的开发场景下的默认配置，以达到快速开发的目的。例如：</p><ol><li>SpringBoot默认扫描启动类所造包下的所有注解，注册成为bean</li><li>SpringBoot默认servlet请求中的上传文件的最大大小是1MB</li><li>……</li></ol><blockquote><p>  这些配置的值最终都会映射到某一个类上，这些类都会被注册为bean。</p></blockquote><h3 id="2-一些核心注解"><a href="#2-一些核心注解" class="headerlink" title="2. 一些核心注解"></a>2. 一些核心注解</h3><h4 id="2-1-Configuration"><a href="#2-1-Configuration" class="headerlink" title="2.1 @Configuration"></a>2.1 @Configuration</h4><p>带有@<strong>Configuration</strong>注解的类可以看做是原生Spring中的xml配置文件，每一个带有@Bean的方法都相当于是注册了一个bean，bean名称默认是方法名，可以通过name属性指定。</p><blockquote><p>  proxyBeanMethods</p></blockquote><p><strong>proxyBeanMethods</strong>属性是配置类中较为重要的属性，也是SpringBoot实现Full&#x2F;Lite模式的关键属性。<br><strong>proxyBeanMethods</strong>含义是设置配置类是否启用代理模式，默认为true。true模式下，每次调用配置类中返回bean的方法时，都会先去容器中查找是否有当前实例，保证了实例的<strong>单例性</strong>，此时就称为Full模式；当proxyBeanMethods为false时，配置类不会开启代理模式，每次调用配置类中的方法获取bean，不进行判断，直接创建一个新的实例并返回，此时就是Lite模式。</p><blockquote><p>  俩种模式的选取建议：当配置类中的Bean没有被其他组件依赖时，使用Lite模式，加快容器启动速度，减少判断；当配置类中的bean被依赖时，使用Full模式。</p></blockquote><h4 id="2-2-Import"><a href="#2-2-Import" class="headerlink" title="2.2 @Import"></a>2.2 @Import</h4><blockquote><p>  @Import用于手动注册bean到容器中，可以添加到@SpringBootApplication(启动类)、@Configuration(配置类)、@Component(组件类)上。</p></blockquote><pre><code>@Import&#123;XXX1.class, XXX2.class&#125;</code></pre><h4 id="2-3-Conditional"><a href="#2-3-Conditional" class="headerlink" title="2.3 @Conditional"></a>2.3 @Conditional</h4><blockquote><p>  @Conditional含义是条件装配，Spring中提供了很多派生注解来满足不同场景下的条件装配，例如：   </p></blockquote><ul><li>@ConditionalOnBean(name&#x3D;”xxx”) 当容器中存在指定名称的bean实例时，注册当前bean</li><li>@ConditionalOnMissingBean (name&#x3D;”xxx”)  当容器中不存在指定名称的bean实例时，注册当前bean</li><li>@ConditionalOnWarDeployment 当项目为war包部署时，注册当前bean</li><li>@ConditionalOnProperty 当存在某个参数时候，注册当前bean</li><li>……</li></ul><h4 id="2-4-ImportResource"><a href="#2-4-ImportResource" class="headerlink" title="2.4 @ImportResource"></a>2.4 @ImportResource</h4><blockquote><p>  @ImportResource的作用是解析原生spring中的xml配置文件，导入其中的配置信息</p></blockquote><pre><code>@ImportResource(&quot;classpath:xxx.xml&quot;)</code></pre><h4 id="2-5-ConfigurationProperties"><a href="#2-5-ConfigurationProperties" class="headerlink" title="2.5 @ConfigurationProperties"></a>2.5 @ConfigurationProperties</h4><h5 id="2-5-1-Component-ConfigurationProperties"><a href="#2-5-1-Component-ConfigurationProperties" class="headerlink" title="2.5.1 @Component+@ConfigurationProperties"></a>2.5.1 @Component+@ConfigurationProperties</h5><blockquote><p>  @ConfigurationProperties的作用是将核心配置文件配置文件中的配置信息绑定到bean中的属性，该注解只能使用在被容器管理的bean上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;xxx&quot;)</span><br><span class="line">public class XXX &#123;&#125;    </span><br></pre></td></tr></table></figure><h5 id="2-5-2-EnableConfigurationProperties-ConfigurationProperties"><a href="#2-5-2-EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="2.5.2 @EnableConfigurationProperties+@ConfigurationProperties"></a>2.5.2 @EnableConfigurationProperties+@ConfigurationProperties</h5><blockquote><p>  大多数场景下，SpringBoot回避免直接在某个类上加@Component注解，这时就需要第二种获取配置信息的注解，在某个类上加@ConfigurationProperties注解用于接收配置信息，在另外一个<strong>配置类</strong>上加@EnableConfigurationProperties并且指定刚刚的参数映射类，可以达到一样的效果，SpringBoot底层大量使用了这种方式，例如kafka自动配置：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.kafka&quot;)</span><br><span class="line">public class KafkaProperties &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnClass(KafkaTemplate.class)</span><br><span class="line">@EnableConfigurationProperties(KafkaProperties.class)</span><br><span class="line">public class KafkaAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-自动装配原理入门"><a href="#3-自动装配原理入门" class="headerlink" title="3. 自动装配原理入门"></a>3. 自动装配原理入门</h3><blockquote><p>  由源码可知，@SpringBootApplication是一个合成注解，其中包含的三个核心注解，实现了自动装配的功能。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="3-1-SpringBootConfiguration"><a href="#3-1-SpringBootConfiguration" class="headerlink" title="3.1 @SpringBootConfiguration"></a>3.1 @SpringBootConfiguration</h4><blockquote><p>  源码可知，@SpringBootConfiguration其内部就是一个@Confiuration配置类，并且设置了proxyBeanMethods默认值为true；</p></blockquote><h4 id="3-2-ComponentScan"><a href="#3-2-ComponentScan" class="headerlink" title="3.2 @ComponentScan"></a>3.2 @ComponentScan</h4><blockquote><p>  包扫描注解的高级用法，引入了SpringBoot中俩个自定义的扫描器，完成了包扫描的设置。</p></blockquote><h4 id="3-3-EnableAutoConfiguration"><a href="#3-3-EnableAutoConfiguration" class="headerlink" title="3.3 @EnableAutoConfiguration"></a>3.3 @EnableAutoConfiguration</h4><blockquote><p>  @EnableAutoConfiguration是实现自动装配最核心的注解，也是一个合成注解，其内部是：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></pre></td></tr></table></figure><h5 id="3-3-1-AutoConfigurationPackage"><a href="#3-3-1-AutoConfigurationPackage" class="headerlink" title="3.3.1 @AutoConfigurationPackage"></a>3.3.1 @AutoConfigurationPackage</h5><p>@AutoConfigurationPackage内部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123;Registrar.class&#125;)</span><br></pre></td></tr></table></figure><p>而Registrar源码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的实际含义就是找到主启动类所在的包，扫描这个包下的所有注解，完成bean注册。</p><h5 id="3-3-2-Import-AutoConfigurationImportSelector-class"><a href="#3-3-2-Import-AutoConfigurationImportSelector-class" class="headerlink" title="3.3.2 @Import({AutoConfigurationImportSelector.class})"></a>3.3.2 @Import({AutoConfigurationImportSelector.class})</h5><blockquote><p>  引入AutoConfigurationImportSelector类，最终的导入逻辑落到了这段代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">result = new HashMap&lt;&gt;();</span><br><span class="line">try &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">while (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = new UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">String[] factoryImplementationNames =</span><br><span class="line">StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">for (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;())</span><br><span class="line">.add(factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Replace all lists with unmodifiable lists containing unique elements</span><br><span class="line">result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><p>由此可知，SpringBoot在启动时会扫描所有jar包下的META-INF&#x2F;spring.factories文件，加载其中的配置信息，关键在于spring-boot-autoconfigure-2.6.3.jar中的META-INF&#x2F;spring.factories文件，这个文件中有一段配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>所以，综上所述，SpringBoot做的事其实就是将J2EE开发所以用到的所有解决方案整合到spring-boot-autoconfigure-2.6.3.jar中的META-INF&#x2F;spring.factories文件中，SpringBoot在容器启动时，会加载这个文件中所有配置，但是查看autoconfigure包中的源码可以发现，其中所有的配置类都是条件装配(@Conditional)，这样，只要导入了对应的starter，容器就会帮我们完成自动配置。</p><blockquote><p>  由autoconfigure包中的源码可知，SpringBoot会在底层做好所有的配置，但如果用户配置了自己的实例，则以用户的优先。</p></blockquote><p>总结：</p><blockquote><p>  SpringBoot启动时会加载所有的自动配置类(XXXAutoConfiguration),<br>  每个自动配置类会按条件进行注册，大部分配置类还会关联外部的配置项,所以SpringBoot整合的组件都可以从application.properties中获取配置信息。由此，SpringBoot既完成了自动装配，按需加载的容器实现，又极大地简化了开发配置。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/11/DockerFile%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/11/11/DockerFile%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DockerFile"><a href="#1-DockerFile" class="headerlink" title="1. DockerFile"></a>1. DockerFile</h3><blockquote><p>​DockerFile是用来构建Docker镜像的的构建文件，是由一系列命令和参数组成的脚本。</p></blockquote><h4 id="1-1-DockerFile内容基础"><a href="#1-1-DockerFile内容基础" class="headerlink" title="1.1 DockerFile内容基础"></a>1.1 DockerFile内容基础</h4><ol><li>每条<strong>Docker指令</strong>都必须大写，并且后变最少跟随一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ol><h4 id="1-2-DockerFile指令详解"><a href="#1-2-DockerFile指令详解" class="headerlink" title="1.2 DockerFile指令详解"></a>1.2 DockerFile指令详解</h4><ol><li>FROM 指定当前镜像是基于哪个镜像的</li><li>MAINTAINER 镜像维护者的姓名和邮箱地址</li><li>RUN 容器构建时要运行的命令</li><li>EXPOSE 容器启动后对外暴露出的端口</li><li>WORKDIR 指定容器启动后，终端登录进来默认的路径</li><li>ENV 用于在构建镜像的过程中设置环境变量</li><li>ADD 将宿主机中的文件复制到容器并且自动处理URL和tar包解压</li><li>COPY</li><li>VOLUMES 容器数据卷，用于挂载数据卷</li><li>CMD 指定容器启动时要运行的命令，DockerFile中只有最后一个CMD会生效，并且会被run参数替换</li><li>ENTRYPOINT 指定容器启动时候要运行的命令</li><li>ONBUILD 当前镜像被继承时要执行的命令，即父镜像被子镜像继承，子镜像构建时会触发父镜像的ONBUILD指令</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/11/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/11/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>docker images</td><td></td><td>列出本地所有镜像</td></tr><tr><td>docker images</td><td>-a</td><td>列出本地所有镜像，包含中间层</td></tr><tr><td>docker images</td><td>-q</td><td>列出本地所有镜像的ID</td></tr><tr><td>docker images</td><td>–digests</td><td>列出本地所有镜像的摘要信息</td></tr><tr><td>docker images</td><td>–digests –no-trunc</td><td>列出本地所有镜像的详细信息</td></tr><tr><td>docker search XXX</td><td></td><td>搜索镜像</td></tr><tr><td>docker pull XXX</td><td></td><td>拉取镜像，默认拉取:latest</td></tr><tr><td>docker pull XXX:[tag]</td><td></td><td>拉取制定标签镜像</td></tr><tr><td>docker rmi XXX:[tag]</td><td></td><td>删除镜像</td></tr><tr><td>docker run</td><td></td><td>运行容器</td></tr><tr><td>docker run</td><td>–name&#x3D;”xxx”</td><td>运行容器同时指定名称</td></tr><tr><td>docker run</td><td>-d</td><td>后台运行容器，并返回容器ID</td></tr><tr><td>docker run</td><td>-i</td><td>以交互模式运行容器，通常与-t同时使用</td></tr><tr><td>docker run</td><td>-t</td><td>为容器分配一个伪终端，通常与-i同时使用</td></tr><tr><td>docker run</td><td>-P</td><td>随机端口映射</td></tr><tr><td>docker run</td><td>-p</td><td>指定端口映射，有4种格式，最常用的是host_port:container_port</td></tr><tr><td>docker ps</td><td></td><td>列出当前运行的所有容器</td></tr><tr><td>docker ps</td><td>-a</td><td>列出当前运行的所有容器+历史运行过的</td></tr><tr><td>docker ps</td><td>-l</td><td>列出最近创建的容器</td></tr><tr><td>docker ps</td><td>-n <x></td><td>列出最近n个创建的容器</td></tr><tr><td>docker ps</td><td>-q</td><td>静默模式，只显示容器编号</td></tr><tr><td>docker restart XXX</td><td></td><td>重启容器</td></tr><tr><td>docker stop XXX</td><td></td><td>停止容器</td></tr><tr><td>docker restart XXX</td><td></td><td>强制停止容器</td></tr><tr><td>docker logs XXX</td><td></td><td>查看容器日志</td></tr><tr><td>docker logs</td><td>-f</td><td>跟随最新的日志</td></tr><tr><td>docker logs</td><td>-t</td><td>日志增加时间戳</td></tr><tr><td>docker logs</td><td>–tail <x></td><td>查看最后x行日志</td></tr><tr><td>docker top XXX</td><td></td><td>查看容器内部运行的进程</td></tr><tr><td>docker inspect XXX</td><td></td><td>查看容器详细信息</td></tr><tr><td>docker attacth XXX</td><td></td><td>直接进入容器终端，不会启动新的进程</td></tr><tr><td>docker exec XXX</td><td></td><td>在容器中打开新的终端，并且可以启动新的进程</td></tr><tr><td>docker cp &#x2F;xxx <container>:&#x2F;xxx</td><td></td><td>宿主机往容器中拷贝文件</td></tr><tr><td>docker cp <container>:&#x2F;xxx &#x2F;xxx</td><td></td><td>容器中往宿主机拷贝文件</td></tr><tr><td>docker commit XXX</td><td></td><td>提交容器副本使之成为一个新的镜像</td></tr></tbody></table><p>docker commit命令演示</p><blockquote><p>  docker commit -m&#x3D;”描述信息” -a&#x3D;”作者” container_id 镜像名字:[标签名]</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/11/Docker%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/11/11/Docker%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Docker镜像-images"><a href="#1-Docker镜像-images" class="headerlink" title="1. Docker镜像(images)"></a>1. Docker镜像(images)</h3><blockquote><p>  <strong>Docker镜像是一种轻量级、可执行的独立软件包。它包含了某个运行环境所需要的内容，包括依赖、运行时、环境变量和配置文件等。</strong></p></blockquote><h4 id="1-1-UnionFS-联合文件系统"><a href="#1-1-UnionFS-联合文件系统" class="headerlink" title="1.1 UnionFS(联合文件系统)"></a>1.1 UnionFS(联合文件系统)</h4><blockquote><p>  UnionFS是一种分层、轻量并且高性能的文件系统，它支持<strong>将文件系统的修改作为一次提交一层层的叠加</strong>，UnionFS文件系统是Docker镜像的基础。</p></blockquote><h4 id="1-2-Docker的镜像加载原理"><a href="#1-2-Docker的镜像加载原理" class="headerlink" title="1.2 Docker的镜像加载原理"></a>1.2 Docker的镜像加载原理</h4><h5 id="1-2-1-bootfs-boot-file-system"><a href="#1-2-1-bootfs-boot-file-system" class="headerlink" title="1.2.1 bootfs(boot file system)"></a>1.2.1 bootfs(boot file system)</h5><blockquote><p>  bootfs主要包含bootloader和kernel，bootloader主要是作用是引导加载kernel。<strong>bootfs是Docker镜像的最底层</strong>，当bootfs加载完成之后，Docker的内存使用权转交给了linux的内核，此时就会卸载bootfs。</p></blockquote><h5 id="1-2-2-rootfs-root-file-system"><a href="#1-2-2-rootfs-root-file-system" class="headerlink" title="1.2.2 rootfs(root file system)"></a>1.2.2 rootfs(root file system)</h5><blockquote><p>  rootfs在bootfs之上，包含了典型linux系统中的标准目录和文件，例如&#x2F;usr &#x2F;etc &#x2F;dev等，相当于实现了一个<strong>精简版的发行版linux系统</strong>，例如Ubuntu、CentOS等。</p></blockquote><p>  对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，底层直接使用宿主机host的kernel，这就是Docker镜像可以做到很小的原因。并且Docker镜像的分层文件系统的每一层都可以进行资源共享。</p><p>  另外需要注意的是，<strong>Docker镜像的文件层都是只读的</strong>，当Docker容器启动时，一个新的可写层会被加载到镜像的顶部，这一层通常称为“容器层”，容器层的下层都称为“镜像层”。</p><h3 id="2-容器数据卷-volume"><a href="#2-容器数据卷-volume" class="headerlink" title="2. 容器数据卷(volume)"></a>2. 容器数据卷(volume)</h3><blockquote><p>  卷的设计目的就是容器的数据持久化和数据共享，独立在容器的生命周期之外，Docker不会在删除容器时删除其挂载的数据卷。</p></blockquote><h4 id="2-1-数据卷挂载的命令"><a href="#2-1-数据卷挂载的命令" class="headerlink" title="2.1 数据卷挂载的命令"></a>2.1 数据卷挂载的命令</h4><p>启动容器时挂载数据卷的命令：</p><pre><code>docker run -v /宿主机路径:/容器内路径 镜像名</code></pre><p>例如：</p><pre><code>docker run -v /docker-volume/redis:/volume redis</code></pre><p>启动容器时挂载<strong>只读</strong>数据卷的命令：</p><pre><code>docker run -v /宿主机路径:/容器内路径:ro 镜像名</code></pre><p>例如：</p><pre><code>docker run -v /docker-volume/redis:/volume:ro redis</code></pre><p>挂载了只读数据卷后，容器对卷只有读权限，没有写权限。</p><h4 id="2-2-DockerFile中挂载卷"><a href="#2-2-DockerFile中挂载卷" class="headerlink" title="2.2 DockerFile中挂载卷"></a>2.2 DockerFile中挂载卷</h4><p>编写DockerFile如下，文件名为volume-test</p><pre><code>#volume testFROM centos:latestVOLUME [&quot;/volume1&quot;,&quot;/volume2&quot;]CMD echo &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;docker started&quot;CMD /bin/bash</code></pre><p>执行命令</p><pre><code>docker build -f /xxx/xxx/volume-test -t hic/ctos .-f 表示指定DockerFile-t 不知道啥意思，后边跟镜像名称最后的 . 也没明白啥意思</code></pre><p>执行后会在本地构建好镜像hic&#x2F;ctos，之后启动该镜像，启动好以后用inspect命令查看镜像详细信息，信息中包含如下：</p><pre><code>&quot;Mounts&quot;: [        &#123;            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;7eb57a72c7c541caae610a5b36e4ba7974369dc929930ee26747f7511b896a96&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/7eb57a72c7c541caae610a5b36e4ba7974369dc929930ee26747f7511b896a96/_data&quot;,            &quot;Destination&quot;: &quot;/volume1&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        &#125;,        &#123;            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;f40e01c85d4c9675fad55cbb903b7c3f40841d6a6ed1d46fd8bbf4f4934b07fb&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/f40e01c85d4c9675fad55cbb903b7c3f40841d6a6ed1d46fd8bbf4f4934b07fb/_data&quot;,            &quot;Destination&quot;: &quot;/volume2&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        &#125;    ],</code></pre><p>可以看到，容器已经挂载了volume1、volume2俩个卷。</p><h4 id="2-3-2-3-数据卷的传递和共享-volumes-from"><a href="#2-3-2-3-数据卷的传递和共享-volumes-from" class="headerlink" title="2.3 2.3 数据卷的传递和共享(volumes-from)"></a>2.3 2.3 数据卷的传递和共享(volumes-from)</h4><p>还是之前的镜像hic&#x2F;ctos</p><pre><code>#volume testFROM centos:latestVOLUME [&quot;/volume1&quot;,&quot;/volume2&quot;]CMD echo &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;docker started&quot;CMD /bin/bash</code></pre><p>启动该镜像，命名为dc01</p><pre><code>docker run -it --name dc01 hic/ctos</code></pre><p>容器dc01已经成功挂载了&#x2F;volume1、&#x2F;volume2俩个卷。</p><p>再执行命令</p><pre><code>docker run -it --name dc02 --volumes-from dc01 hic/ctos    </code></pre><p> 进入容器dc02查看，发现容器内部也已经成功挂载了&#x2F;volume1、&#x2F;volume2，删除掉容器dc01后，dc02的挂载仍然生效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/11/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
      <url>/2022/11/11/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="git操作手册"><a href="#git操作手册" class="headerlink" title="git操作手册"></a>git操作手册</h1><p>查看<strong>本地</strong>所有分支</p><p><code>git branch</code></p><p>查看<strong>远程</strong>仓库所有分支</p><p><code>git branch -a</code></p><p>将远程仓库里的指定分支拉取到本地（本地不存在的分支）</p><p><code>git checkout -b 本地分支名 origin/远程分支名</code></p><p>这样在本地会自动创建一个新分支，并与指定的远程分支关联起来，并且会自动切换到该本地分支</p><p>如果出现以下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#x27;dev2&#x27; at the same time.</span><br><span class="line">Did you intend to checkout &#x27;origin/dev2&#x27; which can not be resolved as commit?</span><br></pre></td></tr></table></figure><p>表示拉取不成功，先执行<code>git fetch</code>，再执行上述代码即可</p><p>切换到其他分支</p><p><code>git checkout 分支名</code></p><p>拉取<strong>最新</strong>的信息</p><p><code>git pull</code></p><p>查看其他人的推送记录</p><p><code>git log</code></p><p>提交修改后的文件</p><p><code>git commit -am &#39;提交记录&#39;</code></p><p>将提交推送至远程仓库</p><p><code>git push</code></p><p>为当前仓库设置提交作者的姓名和邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;xxx&quot;</span><br><span class="line">git config user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure><p>将指定分支合并到当前分支</p><p><code>git merge 分支名</code></p><p>删除<strong>远程</strong>分支</p><ol><li>同步远程分支信息 <code>git fetch -p origin</code></li><li>删除对应分支 <code>git push origin --delete 分支名</code></li></ol><p>删除本地分支</p><p><code>git branch -d 分支名</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/07/hello-world/"/>
      <url>/2022/11/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
