<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring默认标签之alias、import标签的解析</title>
      <link href="/2024/01/17/Spring_tag_parse2/"/>
      <url>/2024/01/17/Spring_tag_parse2/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring默认标签之alias、import标签的解析"><a href="#Spring默认标签之alias、import标签的解析" class="headerlink" title="Spring默认标签之alias、import标签的解析"></a>Spring默认标签之alias、import标签的解析</h3><h4 id="alias标签的解析"><a href="#alias标签的解析" class="headerlink" title="alias标签的解析"></a>alias标签的解析</h4><p>​在对 <strong>bean</strong> 进行定义时，除了使用<strong>id属性</strong>来指定名称之外，为了提供多个名称，可以使用 <strong>alias 标签</strong>来指定。而所有的这些名称都指向同一个 <strong>bean</strong>，在某些情况下提供别名非常有用，比如为了让应用的每一个组件能更容易地又对公共组件进行引用。</p><p>​然而，在定义<strong>bean</strong>时就指定所有的别名并不是总是恰当的。有时我们期望能在当前位置为那些在别处定义的<strong>bean</strong> 引人别名。在XML配置文件中，可用单独的**<alias/><strong>元素来完成</strong>bean** 别名的定义。</p><p>如配置文件中定义了 一个 JavaBean:<br><code>&lt;bean id=&quot;testBean&quot; class=&quot;com.test&quot;/&gt;</code><br>要给这个JavaBean增加别名，以方 方便不同对象来调用。我们就可以直接使用bean标签中 的 name 属性:<br><code>&lt;bean id=&quot;testBean&quot; name=&quot;testBean,testBean2&quot; class=&quot;com.test&quot;/&gt;</code></p><p>同样，Spring还有另外一种声明别名的方式:</p><p><code>&lt;bean id=&quot;testBean&quot; class=&quot;com.test&quot;/&gt;</code><br><code>&lt;alias name=&quot;testBean&quot; alias=&quot;testBean,testBean2&quot;/&gt;</code></p><p>​考虑一个更为具体的例子，组件A在XML配置文件中定义了一个名为componentA的 DataSource 类型的bean，但组件B却想在其XML 文件中以componentB命名来引用此 bean。而且在主程序 MyApp的XML配置文件中，希望以 myApp的名字来引用此bean。最后容器加载3个XML文件来生成最终的ApplicationContext。在此情形下，可通过在配置文件中添加下列 alias 元素来实现:</p><p><code>&lt;alias name=&quot;componentA&quot; alias=&quot;componentB&quot;/&gt;</code></p><p><code>&lt;alias name=&quot;componentA&quot; alias=&quot;myApp&quot;/&gt;</code></p><p>这样一来，每个组件及主程序就可通过唯一名字来引用同一个数据源而互不干扰。</p><p>下面是对alias标签的解析过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processAliasRegistration</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">   <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Name must not be empty&quot;</span>, ele);</span><br><span class="line">      valid = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Alias must not be empty&quot;</span>, ele);</span><br><span class="line">      valid = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to register alias &#x27;&quot;</span> + alias +</span><br><span class="line">               <span class="string">&quot;&#x27; for bean with name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，跟之前讲过的bean中的alias解析大同小异，都是<strong>将别名与beanName组成一对注册至registry中。</strong></p><h4 id="import标签的解析"><a href="#import标签的解析" class="headerlink" title="import标签的解析"></a>import标签的解析</h4><p>在Spring中，import标签的用法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;customerContext.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;systemContext.xml&quot;</span> /&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​<strong>applicationContext.xml</strong>文件中使用<strong>import</strong>方式导入有模块配置文件，以后若要新增模块，修改这个文件即可。这样会大大简化后期维护的复杂度。</p><p>以下为Spring解析import标签的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">importBeanDefinitionResource</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取resource属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">   <span class="comment">// 如果resource属性不存在，则直接return</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Resource location must not be empty&quot;</span>, ele);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Resolve system properties: e.g. &quot;$&#123;user.dir&#125;&quot;</span></span><br><span class="line">   location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">   Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Discover whether the location is an absolute or relative URI</span></span><br><span class="line">   <span class="comment">// 判断location是绝对还是相对URI</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">absoluteLocation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">      <span class="comment">// cannot convert to an URI, considering the location relative</span></span><br><span class="line">      <span class="comment">// unless it is the well-known Spring prefix &quot;classpath*:&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Absolute or relative?</span></span><br><span class="line">   <span class="comment">// 如果是绝对URI 直接根据地址加载对应配置文件</span></span><br><span class="line">   <span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">importCount</span> <span class="operator">=</span> getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(</span><br><span class="line">               <span class="string">&quot;Failed to import bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No URL -&gt; considering resource location as relative to the current file.</span></span><br><span class="line">      <span class="comment">// 如果是相对地址，根据相对地址算出绝对地址</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">int</span> importCount;</span><br><span class="line">         <span class="type">Resource</span> <span class="variable">relativeResource</span> <span class="operator">=</span> getReaderContext().getResource().createRelative(location);</span><br><span class="line">         <span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">            importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">            actualResources.add(relativeResource);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">baseLocation</span> <span class="operator">=</span> getReaderContext().getResource().getURL().toString();</span><br><span class="line">            importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                  StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to resolve current resource location&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to import bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>,</span><br><span class="line">               ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> <span class="title class_">Resource</span>[<span class="number">0</span>]);</span><br><span class="line">   getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上述代码，Spring解析import标签的大致流程如下：</p><ol><li>获取resource属性所表示的路径。</li><li>解析路径中的系统属性。</li><li>判断location是绝对路径还是相对路径</li><li>如果是绝对路径则递归调用bean的解析过程，进行另一次的解析。</li><li>如果是相对路径则计算出绝对路径并进行解析。</li><li>通知监听器，解析完成。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring默认标签-bean标签的解析</title>
      <link href="/2024/01/14/Spring_tag_parse/"/>
      <url>/2024/01/14/Spring_tag_parse/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring默认标签-bean标签的解析"><a href="#Spring默认标签-bean标签的解析" class="headerlink" title="Spring默认标签-bean标签的解析"></a>Spring默认标签-bean标签的解析</h3><blockquote><p><strong>Spring</strong>中的标签包括<strong>默认标签</strong>和<strong>自定义标签</strong>，两种标签的用法及解析方式存在很大的不同，下面主要分析<strong>默认标签</strong>的解析过程。</p></blockquote><p>​默认标签的解析是在<strong>parseDefaultElement</strong>函数中进行的，分别对4种不同的标签<strong>import、alias、bean、beans</strong>做了不同的处理。</p><blockquote><p><strong>DefalutBeanDefinitionDocumentReader.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="comment">// 对import标签的处理</span></span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对alias标签的处理</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对bean标签的处理</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对beans标签的处理</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// recurse</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bean标签的解析及注册"><a href="#bean标签的解析及注册" class="headerlink" title="bean标签的解析及注册"></a>bean标签的解析及注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先委托<strong>BeanDefinitionDelegate</strong>类的<strong>parseBeanDefinitionElement</strong>方法进行元素解析，返回<strong>BeanDefinitionHolder</strong>类型的<strong>bdHolder</strong>实例，经过此方法后，<strong>bdHolder</strong>实例已经包含配置文件中的各种属性了，例如<strong>class、id、name、alias</strong>之类的属性。</li><li>当返回的<strong>bdHolder</strong>不为空的情况下若存在默认标签的子节点下再有<strong>自定义属性</strong>，还需要再次对自定义标签进行解析。</li><li>解析完成后，需要对解析后的<strong>bdHolder</strong>进行<strong>注册</strong>，注册操作委托给了<strong>BeanDefinitionReaderUtils</strong>类的<strong>registerBeanDefinition</strong>方法。</li><li>最后发出响应事件，通知相关的<strong>监听器</strong>，这个<strong>bean</strong>已经加载完了。</li></ol><h5 id="解析BeanDefinition"><a href="#解析BeanDefinition" class="headerlink" title="解析BeanDefinition"></a>解析BeanDefinition</h5><p>下面从元素解析及信息提取开始分析</p><blockquote><p><strong>BeanDefinitionParserDelegate.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">   <span class="comment">// 解析id属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   <span class="comment">// 解析name属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//分割name属性</span></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不存在beanName，那么根据Spring中提供的命名规则为当前bean生成beanName</span></span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">               <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">               <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程如下：</p><ol><li>提取元素中的<strong>id</strong>及<strong>name</strong>属性。</li><li>进一步解析其他属性并统一封装至<strong>GenericBeanDefinition</strong>类型的实例中。</li><li>如果检测到<strong>bean</strong>没有<strong>指定beanName</strong>，那么使用默认规则为此<strong>bean</strong>生成<strong>beanName</strong>。</li><li>将获取到的信息封装至<strong>BeanDefinitionHolder</strong>实例中。</li></ol><p>进一步查看除了id和name属性外其他属性的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">      Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 解析class属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析parent属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">      parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建用于承载属性的AbstractBeanDefinition类型的GenericBeanDefinition</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 硬编码解析默认bean的各种属性</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        <span class="comment">// 提取description</span></span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析元数据</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析lookup-method属性</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析replace-method属性</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析构造函数参数</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析property子元素</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析qualifier子元素</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>BeanDefinition</strong>是一个接口，在<strong>Spring</strong>中有三种实现：<strong>RootBeanDefinition</strong>、<strong>ChildBeanDefinition</strong>以及<strong>GenericBeanDefinition</strong>。三种实现均继承了<strong>AbstractBeanDefinition</strong>，其中<strong>BeanDefinition</strong>是配置文件**<bean><strong>元素标签在容器中的</strong>内部表现形式<strong>。</strong><bean><strong>元素标签拥有class、scope、lazy-lnit等配置属性，</strong>BeanDefinition<strong>则提供了相应的beanClass、scope、lazyInit属性，</strong>BeanDefinition<strong>和</strong><bean><strong>中的属性是</strong>一一对应<strong>的。其中</strong>RootBeanDefinition<strong>是最</strong>常用<strong>的实现类，它对应一般性的</strong><bean>**元素标签。</p><p>​在配置文件中可以定义<strong>父<bean>和子<bean><strong>，父<bean>用</strong>RootBeanDefinition</strong>表示，而子<bean>用<strong>ChildBeanDefiniton</strong>表示，而没有父<bean>的<bean>就使用<strong>RootBeanDefinition</strong> 表示。 <strong>AbstractBeanDefinition</strong> 对两者共同的类信息进行抽象。</p><p>​<strong>Spring</strong> 通过<strong>BeanDefinition</strong>将配置文件中的**<bean><strong>配置信息转换为容器的内部表示，并将这些</strong>BeanDefiniton<strong>注册到</strong>BeanDefinitonRegistry<strong>中。</strong>Spring<strong>容器的</strong>BeanDefinitionRegistry<strong>就像是</strong>Spring配置信息的内存数据库<strong>，主要是以</strong>map<strong>的形式保存，后续操作直接从</strong>BeanDefinition- Registry中读取配置信息**。</p><p>要解析属性首先要创造承载属性的实例</p><p><code>AbstractBeanDefinition bd = createBeanDefinition(className, parent);</code></p><blockquote><p><strong>BeanDefinitionReaderUtils.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">GenericBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">   bd.setParentName(parentName);</span><br><span class="line">   <span class="keyword">if</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">         bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         bd.setBeanClassName(className);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对element所有元素进行解析</p><p><code>parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionAttributes</span><span class="params">(Element ele, String beanName,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> BeanDefinition containingBean, AbstractBeanDefinition bd)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析singleton属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">      error(<span class="string">&quot;Old 1.x &#x27;singleton&#x27; attribute in use - upgrade to &#x27;scope&#x27; declaration&quot;</span>, ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析scope属性</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">      bd.setScope(containingBean.getScope());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析abstract属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析lazy-init属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lazyInit</span> <span class="operator">=</span> ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">      lazyInit = <span class="built_in">this</span>.defaults.getLazyInit();</span><br><span class="line">   &#125;</span><br><span class="line">   bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析autowire属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">autowire</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">   bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析depends-on属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">dependsOn</span> <span class="operator">=</span> ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">      bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析autowire-candidate属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">autowireCandidate</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">candidatePattern</span> <span class="operator">=</span> <span class="built_in">this</span>.defaults.getAutowireCandidates();</span><br><span class="line">      <span class="keyword">if</span> (candidatePattern != <span class="literal">null</span>) &#123;</span><br><span class="line">         String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">         bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析primary属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析init-method属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">      bd.setInitMethodName(initMethodName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getInitMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">      bd.setInitMethodName(<span class="built_in">this</span>.defaults.getInitMethod());</span><br><span class="line">      bd.setEnforceInitMethod(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析destroy-method属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">destroyMethodName</span> <span class="operator">=</span> ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">      bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getDestroyMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">      bd.setDestroyMethodName(<span class="built_in">this</span>.defaults.getDestroyMethod());</span><br><span class="line">      bd.setEnforceDestroyMethod(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析factory-method属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析factory-bean属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析子元素meta</p><p>元数据meta属性使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;myTestBean&quot; class=&quot;bean.MyTestBean&quot;&gt;</span><br><span class="line">&lt;meta key = &quot;testStr&quot; value = &quot;aaaaaaaaa&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>解析子元素lookup-method</p><p>解析子元素replaced-method</p><p>解析子元素constructor-arg</p><p>解析子元素property</p><p>解析子元素qualifier</p><h5 id="AbstractBeanDefinition属性"><a href="#AbstractBeanDefinition属性" class="headerlink" title="AbstractBeanDefinition属性"></a>AbstractBeanDefinition属性</h5><p>​<strong>XML</strong>所有配置都可以在<strong>GenericBeanDefinition</strong>的实例类中找到对应的配置。</p><p>​<strong>GenericBeanDefinition</strong>只是子类实现，大部分的通用属性都保存在了<strong>AbstractBeanDefinition</strong>中。具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">BeanMetadataAttributeAccessor</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">BeanDefinition</span>, Cloneable &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant for the default scope name: &#123;<span class="doctag">@code</span> &quot;&quot;&#125;, equivalent to singleton</span></span><br><span class="line"><span class="comment">    * status unless overridden from a parent bean definition (if applicable).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCOPE_DEFAULT</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates no external autowiring at all.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setAutowireMode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AUTOWIRE_NO</span> <span class="operator">=</span> AutowireCapableBeanFactory.AUTOWIRE_NO;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates autowiring bean properties by name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setAutowireMode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AUTOWIRE_BY_NAME</span> <span class="operator">=</span> AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates autowiring bean properties by type.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setAutowireMode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AUTOWIRE_BY_TYPE</span> <span class="operator">=</span> AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates autowiring a constructor.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setAutowireMode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AUTOWIRE_CONSTRUCTOR</span> <span class="operator">=</span> AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates determining an appropriate autowire strategy</span></span><br><span class="line"><span class="comment">    * through introspection of the bean class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setAutowireMode</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@deprecated</span> as of Spring 3.0: If you are using mixed autowiring strategies,</span></span><br><span class="line"><span class="comment">    * use annotation-based autowiring for clearer demarcation of autowiring needs.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AUTOWIRE_AUTODETECT</span> <span class="operator">=</span> AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates no dependency check at all.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setDependencyCheck</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEPENDENCY_CHECK_NONE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates dependency checking for object references.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setDependencyCheck</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEPENDENCY_CHECK_OBJECTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates dependency checking for &quot;simple&quot; properties.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setDependencyCheck</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.beans.BeanUtils#isSimpleProperty</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEPENDENCY_CHECK_SIMPLE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates dependency checking for all properties</span></span><br><span class="line"><span class="comment">    * (object references as well as &quot;simple&quot; properties).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setDependencyCheck</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEPENDENCY_CHECK_ALL</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constant that indicates the container should attempt to infer the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #setDestroyMethodName destroy method name&#125; for a bean as opposed to</span></span><br><span class="line"><span class="comment">    * explicit specification of a method name. The value &#123;<span class="doctag">@value</span>&#125; is specifically</span></span><br><span class="line"><span class="comment">    * designed to include characters otherwise illegal in a method name, ensuring</span></span><br><span class="line"><span class="comment">    * no possibility of collisions with legitimately named methods having the same</span></span><br><span class="line"><span class="comment">    * name.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Currently, the method names detected during destroy method inference</span></span><br><span class="line"><span class="comment">    * are &quot;close&quot; and &quot;shutdown&quot;, if present on the specific bean class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INFER_METHOD</span> <span class="operator">=</span> <span class="string">&quot;(inferred)&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Object beanClass;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// bean的作用范围，对应bean属性scope</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">String</span> <span class="variable">scope</span> <span class="operator">=</span> SCOPE_DEFAULT;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">abstractFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">autowireMode</span> <span class="operator">=</span> AUTOWIRE_NO;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">dependencyCheck</span> <span class="operator">=</span> DEPENDENCY_CHECK_NONE;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String[] dependsOn;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">autowireCandidate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">primary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> Supplier&lt;?&gt; instanceSupplier;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">nonPublicAccessAllowed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lenientConstructorResolution</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String factoryBeanName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String factoryMethodName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> ConstructorArgumentValues constructorArgumentValues;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> MutablePropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">MethodOverrides</span> <span class="variable">methodOverrides</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodOverrides</span>();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String initMethodName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String destroyMethodName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enforceInitMethod</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enforceDestroyMethod</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">role</span> <span class="operator">=</span> BeanDefinition.ROLE_APPLICATION;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注册解析的BeanDefinition"><a href="#注册解析的BeanDefinition" class="headerlink" title="注册解析的BeanDefinition"></a>注册解析的BeanDefinition</h5><blockquote><p>对于配置文件，首先经过解析，然后再装饰，此时的<strong>beanDefinition</strong>已经满足后续的使用要求了。下面进行注册。也就是<strong>processBeanDefinition</strong>方法中的<code>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析上面代码，可以看出注册<strong>BeanDefinition</strong>分两部分，第一部分是通过<strong>beanName</strong>注册，第二部分是通过<strong>别名</strong>注册。解析的<strong>beanDefinition</strong>会被注册到<strong>BeanDefinitionRegistry</strong>类型的<strong>registry</strong>实例中。</p><h6 id="通过beanName注册"><a href="#通过beanName注册" class="headerlink" title="通过beanName注册"></a>通过beanName注册</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 注册前的最后一次校验，这里的校验不同于之前的xml文件校验</span></span><br><span class="line">  <span class="comment">// 主要是对于AbstractBeanDefinition属性中的methodOverrides校验</span></span><br><span class="line">  <span class="comment">// 校验methodOverrides是否与工厂方法并存或者methodOverrides对应的方法根本不存在</span></span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">               <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">               <span class="string">&quot;Cannot register bean definition [&quot;</span> + beanDefinition + <span class="string">&quot;] for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27;: There is already [&quot;</span> + existingDefinition + <span class="string">&quot;] bound.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                  <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                  existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                  <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                  <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                  <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                  <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="built_in">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Still in startup registration phase</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="built_in">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">      clearByTypeCache();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码大致处理流程如下：</p><ol><li>对<strong>AbstractBeanDefinition</strong>的校验，此处的校验不同于<strong>XML</strong>格式的校验，而是针对于<strong>AbstractBeanDefinition</strong>的<strong>methodOverrides</strong>属性的。</li><li>对<strong>beanName</strong>已经注册的情况的处理，如果设置<strong>允许bean的覆盖</strong>，直接覆盖，否则抛出异常。</li><li>加入<strong>map</strong>缓存</li><li><strong>清除</strong>解析之前留下的对应<strong>beanName</strong>的缓存。</li></ol><h6 id="通过别名注册"><a href="#通过别名注册" class="headerlink" title="通过别名注册"></a>通过别名注册</h6><blockquote><p><strong>SimpleAliasRegistry.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAlias</span><span class="params">(String name, String alias)</span> &#123;</span><br><span class="line">   Assert.hasText(name, <span class="string">&quot;&#x27;name&#x27; must not be empty&quot;</span>);</span><br><span class="line">   Assert.hasText(alias, <span class="string">&quot;&#x27;alias&#x27; must not be empty&quot;</span>);</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.aliasMap) &#123;</span><br><span class="line">      <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.aliasMap.remove(alias);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; ignored since it points to same name&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">registeredName</span> <span class="operator">=</span> <span class="built_in">this</span>.aliasMap.get(alias);</span><br><span class="line">         <span class="keyword">if</span> (registeredName != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">               <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot define alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; for name &#x27;&quot;</span> +</span><br><span class="line">                     name + <span class="string">&quot;&#x27;: It is already registered for name &#x27;&quot;</span> + registeredName + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;Overriding alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; definition for registered name &#x27;&quot;</span> +</span><br><span class="line">                     registeredName + <span class="string">&quot;&#x27; with new target name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         checkForAliasCircle(name, alias);</span><br><span class="line">         <span class="built_in">this</span>.aliasMap.put(alias, name);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; registered for name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以上代码可知，注册<strong>alias</strong>的步骤如下：</p><ol><li><strong>alias</strong>与<strong>beanName</strong>相同时处理。如果alias与beanName相同时不记录alias，并删除原有alias。</li><li><strong>alias覆盖处理</strong>。若aliasName已经使用并已经指向了另一beanName则需要用户的设置进行处理。</li><li><strong>alias循环检查</strong>。当A-&gt;B存在时，若再次出现A-&gt;C-&gt;B时会抛异常。</li><li><strong>注册alias</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring容器的基本实现</title>
      <link href="/2024/01/02/Spring_container_achieve/"/>
      <url>/2024/01/02/Spring_container_achieve/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring容器的基本实现"><a href="#Spring容器的基本实现" class="headerlink" title="Spring容器的基本实现"></a>Spring容器的基本实现</h3><h4 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h4><blockquote><p>在了解核心类前，需要对benas的工程结构有初步的认识</p></blockquote><h5 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h5><p>​<strong>XmlBeanFactory</strong>继承自<strong>DefaultListableBeanFactory</strong>，而<strong>DefaultListableBeanFactory</strong>是整个<strong>bean加载的核心</strong>部分，是<strong>Spring</strong>注册及加载<strong>bean</strong>的<strong>默认实现</strong>。</p><p><a href="https://imgse.com/i/piXSUG4"><img src="https://s11.ax1x.com/2023/12/31/piXSUG4.png" alt="piXSUG4.png"></a></p><p>​<strong>XmlBeanFactory</strong>对<strong>DefaultListableBeanFactory</strong>类进行了扩展，主要用于从<strong>XML</strong>文档中读取<strong>BeanDefinition</strong>，对于<strong>注册及获取bean</strong>都是使用从父类<strong>DefaultListableBeanFactory</strong>继承的方法去实现，而唯独与父类不同的个性化实现就是增加了<strong>XmlBeanDefinitionReader</strong>类型的<strong>reader</strong>属性。在<strong>XmlBeanFactory</strong>中主要使用<strong>reader</strong>属性对资源文件进行<strong>提取和注册。</strong></p><h5 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h5><p>​<strong>XML</strong>配置文件的读取是<strong>Spring</strong>中的重要功能，因为<strong>Spring</strong>的大部分功能都是以<strong>配置</strong>作为切入点的。</p><p><a href="https://imgse.com/i/piXptmt"><img src="https://s11.ax1x.com/2023/12/31/piXptmt.png" alt="piXptmt.png"></a></p><p>一些相关类的功能如下：</p><ul><li><strong>ResourceLoader</strong>：定义资源加载器，根据给定的资源文件地址返回对应的<strong>Resource</strong></li><li><strong>BeanDefinitionReader</strong>：主要定义资源文件读取并转换为<strong>BeanDefinition</strong>的各个功能</li><li><strong>EnvironmentCapable</strong>：定义<strong>获取Environment</strong>方法</li><li><strong>DocumentLoader</strong>：定义从资源文件<strong>加载到转换</strong>为<strong>Document</strong>的功能</li><li><strong>AbstractBeanDefinitionReader</strong>：对<strong>EnvironmentCapable</strong>、<strong>BeanDefinitionReader</strong>类定义的功能进行<strong>实现</strong></li><li><strong>BeanDefinitionDocumentReader</strong>：定义<strong>读取Document</strong>并<strong>注册BeanDefinition</strong>功能</li><li><strong>BeanDefinitionParserDelegate</strong>：定义<strong>解析Element</strong>的各种方法</li></ul><p>整个<strong>XML配置文件读取</strong>的大致流程如下：</p><ol><li>通过<strong>继承</strong>自<strong>AbstractBeanDefinitionReader</strong>中的方法，来使用<strong>ResourceLoader</strong>将资源文件路径<strong>转换</strong>为对应的<strong>Resource文件。</strong></li><li>通过<strong>DocumentLoader</strong>对<strong>Resource</strong>文件进行<strong>转换</strong>，将<strong>Resource</strong>文件转换为<strong>Document</strong>文件。</li><li>通过实现<strong>接口BeanDefinitionDocumentReader</strong>的<strong>DefaultBeanDefinitionDocumentReader</strong>类对<strong>Document</strong>进行解析，并使用<strong>BeanDefinitionParserDelegate</strong>对<strong>Element</strong>进行解析。</li></ol><h4 id="容器的基础XmlBeanFactory"><a href="#容器的基础XmlBeanFactory" class="headerlink" title="容器的基础XmlBeanFactory"></a>容器的基础XmlBeanFactory</h4><blockquote><p>接下来分析以下代码的执行过程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;beanFactoryTest.xml&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="配置文件封装"><a href="#配置文件封装" class="headerlink" title="配置文件封装"></a>配置文件封装</h5><p><strong>Spring</strong>配置文件的读取是通过<strong>ClassPathResource</strong>进行封装的。在<strong>Java</strong>中，将不同来源的资源抽象成<strong>URL</strong>，通过注册不同的<strong>handler</strong>来处理不同来源的资源的读取逻辑。<strong>Spring</strong>对其内部使用到的资源实现了自己的抽象结构：<strong>Resource</strong>接口封装底层资源。以下分析使用<strong>Resource</strong>实例作为参数的构造方法。</p><blockquote><p><strong>XmlBeanFactory.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="built_in">this</span>(resource, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">    <span class="comment">// 资源加载的真正实现</span></span><br><span class="line"><span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在资源加载前调用父类构造函数初始化<code>super(parentBeanFactory)</code></p><blockquote><p><strong>AbstractAutowireCapableBeanFactory.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>();</span><br><span class="line">   ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">   ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">   ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ignoreDependencyInterface</strong>方法的作用是<strong>忽略</strong>给定接口的<strong>自动装配</strong>功能。</p><h5 id="加载Bean"><a href="#加载Bean" class="headerlink" title="加载Bean"></a>加载Bean</h5><p>在<strong>XmlBeanFactory</strong>构造函数中调用了<strong>XmlBeanDefinitionReader</strong>类型的<strong>reader</strong>属性提供的方法<code>this.reader.loadBeanDefinitions(resource)</code>，此为整个资源加载的切入点。</p><blockquote><p><strong>XmlBeanDefinitionReader.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过属性来记录已经加载的资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从encodedResources中获取已经封装的Resource对象并再次从Resource中获取其中的inputStream</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// InputSource这个类并不来自于Spring，它的全路径是org.xml.sax.InputSource</span></span><br><span class="line">         <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 真正的逻辑核心部分</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>封装资源文件。当进入<strong>XmlBeanDefinitionReader</strong>后首先对参数<strong>Resource</strong>使用<strong>EncodedResource</strong>类进行封装。</li><li>获取输入流。从<strong>Resource</strong>中获取对应的<strong>InputStream</strong>并构造<strong>InputSource</strong>。</li><li>通过构造的<strong>InputSource</strong>实例和<strong>Resource</strong>实例继续调用函数<strong>doLoadBeanDefinitions</strong>。</li></ol><blockquote><p><strong>XmlBeanDefinitionReader.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 加载XML文件，并得到对应的Document</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">            <span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">            <span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">            <span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">            <span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取对<strong>XML</strong>文件的<strong>验证模式</strong>。</li><li>加载<strong>XML</strong>文件，并得到对应的<strong>Document</strong>。</li><li>根据返回的<strong>Document注册Bean</strong>信息。</li></ol><h4 id="获取XML的验证模式"><a href="#获取XML的验证模式" class="headerlink" title="获取XML的验证模式"></a>获取XML的验证模式</h4><h5 id="DTD与XSD区别"><a href="#DTD与XSD区别" class="headerlink" title="DTD与XSD区别"></a>DTD与XSD区别</h5><p>DTD（Document Type Definition）即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确。</p><p>一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。</p><p>要使用DTD验证模式的时候需要在XML文件的头部声明，以下是使用DTD声明方式的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE validators PUBLIC &quot;-//OpenSymphony Group//XWork Validator 1.0//EN&quot; &quot;http://www.opensymphony.com/xwork/xwork-validator-1.0.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><p>XML Schema语言就是XSD（XML Schemas Definition）。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过XML Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否是有效的。XML Schema本身是一个XML文档，它符合XML语法结构。可以用通用的XML解析器解析它。</p><p>在使用XML Schema文档对XML实例文档进行检验，除了要声明名称空间外（xmlns&#x3D; <a href="http://www.springframework.org/schema/beans%EF%BC%89%EF%BC%8C%E8%BF%98%E5%BF%85%E9%A1%BB%E6%8C%87%E5%AE%9A%E8%AF%A5%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84XML">http://www.springframework.org/schema/beans），还必须指定该名称空间所对应的XML</a> Schema文档的存储位置。通过schemaLocation属性来指定名称空间所对应的XML Schema文档的存储位置，它包含两个部分，一部分是名称空间的URI，另一部分就是该名称空间所标识的XML Schema文件位置或URL地址（xsi:schemaLocation&#x3D;”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> <a href="http://www/">http://www</a>. springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd）。</p><h5 id="验证模式的读取"><a href="#验证模式的读取" class="headerlink" title="验证模式的读取"></a>验证模式的读取</h5><p><strong>Spring</strong>通过<strong>getValidationModeForResource</strong>方法来获取对应资源的<strong>验证模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getValidationModeForResource</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">validationModeToUse</span> <span class="operator">=</span> getValidationMode();</span><br><span class="line">   <span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">      <span class="keyword">return</span> validationModeToUse;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> <span class="variable">detectedMode</span> <span class="operator">=</span> detectValidationMode(resource);</span><br><span class="line">   <span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">      <span class="keyword">return</span> detectedMode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Hmm, we didn&#x27;t get a clear indication... Let&#x27;s assume XSD,</span></span><br><span class="line">   <span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line">   <span class="comment">// detection stopped (before finding the document&#x27;s root tag).</span></span><br><span class="line">   <span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h4><p>经过了验证模式准备的步骤就可以进行<strong>Document</strong>加载了，同样<strong>XmlBeanFactoryReader</strong>类对于文档读取没有亲力亲为，而是委托给了<strong>DocumentLoader</strong>去执行，这里的<strong>DocumentLoader</strong>是个接口，而真正调用的是<strong>DefaultDocumentLoader</strong>，解析代码如下：</p><blockquote><p><strong>DefaultDocumentLoader.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Document <span class="title function_">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span><br><span class="line"><span class="params">      ErrorHandler errorHandler, <span class="type">int</span> validationMode, <span class="type">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">   <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EntityResolver用法"><a href="#EntityResolver用法" class="headerlink" title="EntityResolver用法"></a>EntityResolver用法</h5><p>通过上述代码可以发现，<strong>entityResolver</strong>作为参数传入，该参数通过<strong>getEntityResolver</strong>方法返回而来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> EntityResolver <span class="title function_">getEntityResolver</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.entityResolver == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Determine default EntityResolver to use.</span></span><br><span class="line">      <span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> getResourceLoader();</span><br><span class="line">      <span class="keyword">if</span> (resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="built_in">this</span>.entityResolver = <span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(resourceLoader);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.entityResolver = <span class="keyword">new</span> <span class="title class_">DelegatingEntityResolver</span>(getBeanClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.entityResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​对于解析一个<strong>XML</strong>，<strong>SAX</strong>首先读取该<strong>XML</strong>文档上的<strong>声明</strong>，根据声明去寻找相应的<strong>DTD</strong>定义，以便对文档进行一个验证。默认的寻找规则即通过<strong>网络</strong>来下载相应的<strong>DTD</strong>规则，有时候网络中断，这里就会报错。</p><p>​<strong>EntityResolver</strong>的作用就是项目本身就可以提供一个如何寻找<strong>DTD</strong>声明的方法，即由<strong>程序来实现寻找DTD声明</strong>的过程，比如将<strong>DTD</strong>文件放到项目某处，在实现时直接将此文档读取并返回给<strong>SAX</strong>即可。这样就避免了通过网络来寻找相应的声明。</p><h4 id="解析及注册BeanDefinitions"><a href="#解析及注册BeanDefinitions" class="headerlink" title="解析及注册BeanDefinitions"></a>解析及注册BeanDefinitions</h4><p>在<strong>doLoadBeanDefinitions</strong>方法中，<strong>document</strong>获取到以后，会和<strong>resource</strong>一起被传入到<strong>registerBeanDefinitions</strong>方法这进行<strong>提取及注册bean</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br></pre></td></tr></table></figure><blockquote><p><strong>XmlBeanDefinitionReader.java</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="comment">// 使用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader</span></span><br><span class="line">   <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="comment">// 记录统计前BeanDefinition的加载个数</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 加载及注册bean</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="comment">// 记录本次加载的BeanDefinition个数</span></span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<strong>registerBeanDefinitions</strong>方法内部分析过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">   <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doRegisterBeanDefinitions</strong>方法是真正加载解析<strong>XML</strong>文件的<strong>核心逻辑</strong>部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">   <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">   <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">   <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">   <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">   <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">   <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">   <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">   <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                     <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析前处理，留给子类实现</span></span><br><span class="line">   preProcessXml(root);</span><br><span class="line">   parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">   <span class="comment">// 解析后处理，留给子类实现</span></span><br><span class="line">   postProcessXml(root);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="profile属性的使用"><a href="#profile属性的使用" class="headerlink" title="profile属性的使用"></a>profile属性的使用</h5><p>通过分析上述代码，首先对<strong>profile</strong>进行处理</p><p><strong>profile</strong>的作用是可以同时在配置文件中<strong>部署多套配置</strong>，比如测试环境，开发环境，生产环境，这样可以很<strong>方便的进行切换</strong>不同环境的配置。</p><h5 id="解析并注册BeanDefinition"><a href="#解析并注册BeanDefinition" class="headerlink" title="解析并注册BeanDefinition"></a>解析并注册BeanDefinition</h5><blockquote><p>通过<strong>parseBeanDefinitions</strong>方法进行<strong>bean</strong>的<strong>注册</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在<strong>Spring</strong>的<strong>XML</strong>配置中对于<strong>Bean</strong>的声明有两种，一种是<strong>默认</strong>的，使用<strong>parseDefaultElement</strong>方法解析，另一种是<strong>自定义</strong>声明的，需要用户实现一些接口及配置后，使用<strong>parseCustomElement</strong>方法去注册解析<strong>bean</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8stream流高级用法</title>
      <link href="/2023/07/26/Java8stream%E6%B5%81%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2023/07/26/Java8stream%E6%B5%81%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Java8stream流高级用法"><a href="#Java8stream流高级用法" class="headerlink" title="Java8stream流高级用法"></a>Java8stream流高级用法</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>java8新添加了一个特性：流Stream。Stream让开发者能够以一种<strong>声明</strong>的方式处理数据源（集合、数组等），它专注于对数据源进行各种高效的<strong>聚合操作</strong>（aggregate operation）和<strong>大批量</strong>数据操作 (bulk data operation)。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><h5 id="list根据某个属性去重"><a href="#list根据某个属性去重" class="headerlink" title="list根据某个属性去重"></a>list根据某个属性去重</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例为根据processId属性去重 </span></span><br><span class="line">businessProcesses = businessProcesses</span><br><span class="line">                        .stream()</span><br><span class="line">                        .collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(BusinessProcess::getProcessId))), ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><h5 id="list按某个属性正序排列"><a href="#list按某个属性正序排列" class="headerlink" title="list按某个属性正序排列"></a>list按某个属性正序排列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例为根据createTime属性排序</span></span><br><span class="line">businessProcesses = businessProcesses.stream().sorted(Comparator.comparing(BusinessProcess::getCreateTime))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="list按某个属性分组为map，key就是属性值，value是对应符合条件的list"><a href="#list按某个属性分组为map，key就是属性值，value是对应符合条件的list" class="headerlink" title="list按某个属性分组为map，key就是属性值，value是对应符合条件的list"></a>list按某个属性分组为map，key就是属性值，value是对应符合条件的list</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例为把list中demandId相同的list为一组</span></span><br><span class="line">Map&lt;String, List&lt;BusinessProcess&gt;&gt; processGroupByDemandIdMap = childProcesses.stream().collect(Collectors.groupingBy(BusinessProcess::getDemandId));</span><br></pre></td></tr></table></figure><h5 id="根据关键字查询列表，关键字对应多个属性"><a href="#根据关键字查询列表，关键字对应多个属性" class="headerlink" title="根据关键字查询列表，关键字对应多个属性"></a>根据关键字查询列表，关键字对应多个属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例为searchKeyWord对应userCode、userName、loginAccount3个字段，匹配上任何一个字段均满足条件的情况</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotEmpty(params.getSearchKeyWord())) &#123;</span><br><span class="line">            queryWrapper.and(wrapper -&gt; wrapper.like(StringUtils.isNotBlank(params.getSearchKeyWord()), BtcUser::getUserCode, params.getSearchKeyWord())</span><br><span class="line">                    .or()</span><br><span class="line">                    .like(StringUtils.isNotBlank(params.getSearchKeyWord()), BtcUser::getUserName, params.getSearchKeyWord())</span><br><span class="line">                    .or()</span><br><span class="line">                    .like(StringUtils.isNotBlank(params.getSearchKeyWord()), BtcUser::getLoginAccount, params.getSearchKeyWord())</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mybatisPlus根据lambda表达式设置updateWrapper"><a href="#mybatisPlus根据lambda表达式设置updateWrapper" class="headerlink" title="mybatisPlus根据lambda表达式设置updateWrapper"></a>mybatisPlus根据lambda表达式设置updateWrapper</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set表示要更新的字段，eq表示where条件后面的字段</span></span><br><span class="line">LambdaUpdateWrapper&lt;BtcDemandSnapshot&gt; snapshotLambdaUpdateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;BtcDemandSnapshot&gt;()</span><br><span class="line">.set(BtcDemandSnapshot::getProjectCode, btcDemand.getProjectCode())</span><br><span class="line">.eq(BtcDemandSnapshot::getDemandNumber, params.getDemandNumber())</span><br><span class="line">.eq(BtcDemandSnapshot::getVersion, params.getVersion());</span><br><span class="line"><span class="type">int</span> <span class="variable">demandSnapshotUpdateResult</span> <span class="operator">=</span> btcDemandSnapshotMapper.update(<span class="literal">null</span>, snapshotLambdaUpdateWrapper);</span><br></pre></td></tr></table></figure><h5 id="对象list转map，key为对象中某个属性，value为对象本身"><a href="#对象list转map，key为对象中某个属性，value为对象本身" class="headerlink" title="对象list转map，key为对象中某个属性，value为对象本身"></a>对象list转map，key为对象中某个属性，value为对象本身</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, DemandInfoVo&gt; demandMap = demandList.stream().collect(Collectors.toMap(DemandInfoVo::getDemandNumber, DemandInfoVo -&gt; DemandInfoVo));</span><br></pre></td></tr></table></figure><h5 id="将对象集合按对象某个属性转成字符串并且用逗号分隔"><a href="#将对象集合按对象某个属性转成字符串并且用逗号分隔" class="headerlink" title="将对象集合按对象某个属性转成字符串并且用逗号分隔"></a>将对象集合按对象某个属性转成字符串并且用逗号分隔</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; str = authorityList.stream().map(AuthorityQueryVo::getAuthorityName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 如何获取jar包里面的resource资源文件</title>
      <link href="/2023/06/13/Springboot%20%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96jar%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
      <url>/2023/06/13/Springboot%20%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96jar%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Springboot-如何获取jar包里面的resource资源文件"><a href="#Springboot-如何获取jar包里面的resource资源文件" class="headerlink" title="Springboot 如何获取jar包里面的resource资源文件"></a>Springboot 如何获取jar包里面的resource资源文件</h3><blockquote><p><em>需求：在项目开发中，有时候需要把一些模板文件及静态资源文件放到resource目录中，并且在服务启动的时候去访问这些文件。</em></p></blockquote><p>问题：在本地开发环境中，通过读取对应的文件路径可以正常访问到，但是打成jar包以后，无法通过路径的方式读取到对应文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath();</span><br></pre></td></tr></table></figure><blockquote><p>上述代码在本地没有问题，服务器会报<strong>FileNotFound！</strong></p></blockquote><p>解决方案：</p><p>读取jar里面的静态资源文件时不要使用路径，使用<strong>文件流</strong>读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;&quot;</span>).getInputStream();</span><br></pre></td></tr></table></figure><p>如果需要处理文件，直接用文件流处理，如果必须要通过路径读文件，可以用文件流将文件写入到服务器的目录下，然后再通过路径去读取。</p><p>附上将文件流写入到本地的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将InputStream流写入到本地</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetPath 目标路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeToLocal</span><span class="params">(String targetPath, InputStream inputStream)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetPath);</span><br><span class="line">        <span class="keyword">while</span> ((index = inputStream.read(bytes)) != -<span class="number">1</span>)  &#123;</span><br><span class="line">            fileOutputStream.write(bytes, <span class="number">0</span>, index);</span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 开发遇到的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot与JDK版本对应关系</title>
      <link href="/2023/05/30/SpringBoot%E3%80%81JDK%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/05/30/SpringBoot%E3%80%81JDK%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot版本标识的含义"><a href="#SpringBoot版本标识的含义" class="headerlink" title="SpringBoot版本标识的含义"></a>SpringBoot版本标识的含义</h3><ol><li>CURRENT：代表了当前版本，最新发布版本，里程碑版本</li><li>GA：通用正式发布版本，同release</li><li>SNAPSHOT：快照版本，可用但非稳定版本</li><li>PRE：预览版本</li><li>RC：(Release　Candidate) 软件选版本。系统平台上的发行候选版本。RC版不会再加入新的功能了，主要着重于除错</li><li>Alpha：测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li><li>Beta：测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li></ol><p><a href="https://imgse.com/i/p9jjeDP"><img src="https://s1.ax1x.com/2023/05/30/p9jjeDP.png" alt="p9jjeDP.png"></a></p><p><a href="https://imgse.com/i/p9jjcb6"><img src="https://s1.ax1x.com/2023/05/30/p9jjcb6.png" alt="p9jjcb6.png"></a></p><h3 id="版本对应关系"><a href="#版本对应关系" class="headerlink" title="版本对应关系"></a>版本对应关系</h3><table><thead><tr><th>SpringBoot</th><th>SpringFramework</th><th>JDK</th><th>Maven</th></tr></thead><tbody><tr><td>3.x.x</td><td>5.3.x</td><td>17</td><td>3.6.0+</td></tr><tr><td>2.5.x</td><td>5.3.x</td><td>16,15,11,8</td><td>3.6.0+</td></tr><tr><td>2.4.x</td><td>5.3.x</td><td>16,15,11,8</td><td>3.6.2+</td></tr><tr><td>2.3.x</td><td>5.2.x</td><td>14,13,11,8</td><td>3.5.0+</td></tr><tr><td>2.2.x</td><td>5.2.x</td><td>13,12,11,8</td><td>3.3.0+</td></tr><tr><td>2.1.x</td><td>5.1.x</td><td>11,8</td><td>3.3.0+</td></tr><tr><td>2.0.x</td><td>5.0.x</td><td>9,8</td><td>3.3.0+</td></tr><tr><td>1.5.x</td><td>4.3.x</td><td>8</td><td>3.3.0+</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis中xml文件参数为map时高级用法</title>
      <link href="/2023/03/05/MyBatis%E4%B8%ADXML%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E4%B8%BAmap%E6%97%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2023/03/05/MyBatis%E4%B8%ADXML%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E4%B8%BAmap%E6%97%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="MyBatis中xml文件参数为map时高级用法"><a href="#MyBatis中xml文件参数为map时高级用法" class="headerlink" title="MyBatis中xml文件参数为map时高级用法"></a>MyBatis中xml文件参数为map时高级用法</h3><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><p><strong>下面是使用场景</strong></p><blockquote><p>假设前端将许多的参数以Vo的形式传入，我们在Service蹭、Mapper层都传入Vo，我们在xml中就需要对多个查询参数进行判空，比如下面这样：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">&quot;testXml&quot;</span> <span class="attr">paramsType</span> = <span class="string">&quot;xxx.xxx.Vo&quot;</span> <span class="attr">resultType</span> = <span class="string">&quot;xxx.xxx.Vo&quot;</span>&gt;</span></span><br><span class="line">    select xxx</span><br><span class="line">    from db.table</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;null != param1&quot;</span>&gt;</span></span><br><span class="line">            xxx = #&#123;xxx&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;null != param2&quot;</span>&gt;</span></span><br><span class="line">            xxx = #&#123;xxx&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式实现没有问题，但是有一个小小的弊端就是如果查询参数很多的话，那就要写很多很多的if标签，那么有没有一种类似于循环判断的方式从而不用写那么多if呢？当然有！</p><p>在Service层里面将Vo转成Map后传入Mapper层即可，具体实现如下：</p><p><strong>这是Service层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;UserDepte&gt; <span class="title function_">getByMap</span><span class="params">(UserQueryParams params)</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; paramsMap= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        paramsMap.put(<span class="string">&quot;key&quot;</span>, params.getXxx());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getByMap(paramsMap);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是Mapper层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getByMap</span><span class="params">(<span class="meta">@param(&quot;paramsMap&quot;)</span> Map&lt;String,Object&gt; map)</span></span><br></pre></td></tr></table></figure><p><strong>这是对应的XML文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;paramsMap.keys&quot;</span> <span class="attr">item</span>=<span class="string">&quot;k&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;null != paramsMap[k]&quot;</span>&gt;</span>    </span><br><span class="line">        $&#123;k&#125; = #&#123;paramsMap[$&#123;k&#125;]&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>   </span><br></pre></td></tr></table></figure><blockquote><p>这样就一个循环解决参数判空的问题，而不再需要写一堆if</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java使用OKHttp进行文件上传</title>
      <link href="/2023/03/05/Java%E4%BD%BF%E7%94%A8OKHttp%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/03/05/Java%E4%BD%BF%E7%94%A8OKHttp%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Java使用OKHttp进行文件上传"><a href="#Java使用OKHttp进行文件上传" class="headerlink" title="Java使用OKHttp进行文件上传"></a>Java使用OKHttp进行文件上传</h3><p>使用场景：服务端使用<strong>InputStream</strong>来接收文件</p><p>客户端使用<strong>post</strong>请求</p><p><strong>headerMap</strong>用于存放<strong>请求头</strong>信息</p><p><strong>paramsMap</strong>用于存放<strong>文件</strong>和<strong>字符串</strong>参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postFile</span><span class="params">(String url, HashMap&lt;String, String&gt; headerMap, HashMap&lt;String, Object&gt; paramsMap)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"></span><br><span class="line">        MultipartBody.<span class="type">Builder</span> <span class="variable">builder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartBody</span>.Builder();</span><br><span class="line">        builder1.setType(MultipartBody.FORM);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; stringObjectEntry : paramsMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringObjectEntry.getKey();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> stringObjectEntry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> File) &#123;<span class="comment">//如果请求的值是文件</span></span><br><span class="line">                <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> (File) value;</span><br><span class="line">                <span class="comment">//MediaType.parse(&quot;application/octet-stream&quot;)以二进制的形式上传文件</span></span><br><span class="line">                builder1.addFormDataPart(<span class="string">&quot;file&quot;</span>, ((File) value).getName(), RequestBody.create(MediaType.parse(<span class="string">&quot;multipart/form-data&quot;</span>), file));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果请求的值是string类型</span></span><br><span class="line">                builder1.addFormDataPart(key, value.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Request.<span class="type">Builder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder();</span><br><span class="line">        requestBuilder.url(url);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加请求头</span></span><br><span class="line">        <span class="keyword">if</span>(CollectionUtil.isNotEmpty(headerMap))&#123;</span><br><span class="line">            Set&lt;String&gt; keys = headerMap.keySet();</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> headerMap.get(key);</span><br><span class="line">                requestBuilder.addHeader(key, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        requestBuilder.post(builder1.build()).url(url);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> requestBuilder.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="type">ResponseBody</span> <span class="variable">responseBody</span> <span class="operator">=</span> response.body();</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(responseBody)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;响应体为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">strResponse</span> <span class="operator">=</span> responseBody.string();</span><br><span class="line">            log.info(<span class="string">&quot;打印响应参数:&#123;&#125;&quot;</span>, strResponse);</span><br><span class="line">            <span class="keyword">return</span> strResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端支持上传多个文件，paramsMap中的value设置为File类型的文件即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设现在有多个list：List&lt;File&gt; files</span></span><br><span class="line">Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 字符串类型参数正常设置即可</span></span><br><span class="line">paramsMap.put(<span class="string">&quot;StringKey&quot;</span>, <span class="string">&quot;StringValue&quot;</span>);</span><br><span class="line"><span class="comment">// 文件类型参数设置方式如下：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">    paramsMap.put(<span class="string">&quot;file&quot;</span>+i, files.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java使用httpClient进行文件上传</title>
      <link href="/2023/03/05/Java%E4%BD%BF%E7%94%A8httpClient%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/03/05/Java%E4%BD%BF%E7%94%A8httpClient%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Java使用httpClient进行文件上传"><a href="#Java使用httpClient进行文件上传" class="headerlink" title="Java使用httpClient进行文件上传"></a>Java使用httpClient进行文件上传</h3><p>使用场景：服务端使用<strong>InputStream</strong>来接收文件</p><p>客户端使用<strong>post</strong>请求</p><p>fileNameWithSuffix表示<strong>带后缀</strong>的文件名，例如test.txt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postFile</span><span class="params">(String url, String token, String fileNameWithSuffix, InputStream inputStream)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Authorization&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">        <span class="type">MultipartEntityBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> MultipartEntityBuilder.create();</span><br><span class="line">        builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);</span><br><span class="line">        builder.addBinaryBody(<span class="string">&quot;file&quot;</span>, inputStream, ContentType.create(<span class="string">&quot;multipart/form-data&quot;</span>), fileNameWithSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> builder.build();</span><br><span class="line">        httpPost.setEntity(entity);</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CloseableHttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != httpResponse) &#123;</span><br><span class="line">                <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> httpResponse.getEntity();</span><br><span class="line">                <span class="type">String</span> <span class="variable">responseStr</span> <span class="operator">=</span> EntityUtils.toString(responseEntity, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                log.info(<span class="string">&quot;打印响应信息:&#123;&#125;&quot;</span>, responseStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读万卷书，行万里路</title>
      <link href="/2023/02/19/%E3%80%8A%E4%BA%BA%E7%94%9F%E7%AE%97%E6%B3%95%E3%80%8B/"/>
      <url>/2023/02/19/%E3%80%8A%E4%BA%BA%E7%94%9F%E7%AE%97%E6%B3%95%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="《人生算法》"><a href="#《人生算法》" class="headerlink" title="《人生算法》"></a>《人生算法》</h3><p><strong>用概率思维做好决策</strong></p><blockquote><p>想象你现在中了一个大奖，你有两个选择：直接拿走100万美元；或有50%的概率获得一亿美元，也有50%的可能什么也拿不到，你会怎么选？</p></blockquote><p><a href="https://imgse.com/i/pSLTGQA"><img src="https://s1.ax1x.com/2023/02/19/pSLTGQA.jpg" alt="pSLTGQA.jpg"></a></p><blockquote><p>多数人会选择直接拿走100万美元，因为他们不愿意承受什么都拿不到的风险。事实上如果你打开思路，把获得一亿美元的机会以2000万美元的机会卖给愿意承担风险的人，你就能赚2000万美元，而不是仅仅获得100万美元。这就是算法思维的力量，它决定了人们不一样的人生轨迹。</p></blockquote><p>​        阿西莫夫说：“科学是一个机制，是扩充你对自然的认知的一个方式。科学是一个系统，用宇宙中的事实验证你的想法是否在正确。这个系统很有效，不仅仅是在科学领域，放到日常生活中也很有用处。”人生算法的实用主义背后，正是这类验证，正如我们的一生也是某种验证一样。</p><h3 id="《图解设计模式》"><a href="#《图解设计模式》" class="headerlink" title="《图解设计模式》"></a>《图解设计模式》</h3><p><strong>194张图表轻松理解GoF的23种设计模式</strong></p><blockquote><p>作者：【日】结城浩，生于1963年，日本知名技术作家和程序员。在编程语言、设计模式、数学、加密技术等领域，编写了很多深受欢迎的入门书。代表作有《数学女孩》系列、《程序员的数学》、《图解密码技术》等。</p></blockquote><p><a href="https://imgse.com/i/ppEgbWR"><img src="https://s1.ax1x.com/2023/03/05/ppEgbWR.jpg" alt="ppEgbWR.jpg"></a></p><p>​     本书以浅显易懂的语言逐一说明了GoF的23种设计模式。在讲解过程中不仅搭配了丰富的图片，而且理论结合实例，用Java语言编写代码实现了设计模式的程序，让程序真正的运行起来，并提供了运用模式解决具体问题的练习题和答案。除此以外，本书在必要时还对Java语言的功能进行补充说明，以加深读者对Java的理解。本书适合对面向对象开发感兴趣、对设计模式感兴趣的人以及所有Java程序员阅读。</p>]]></content>
      
      
      <categories>
          
          <category> 这些书值得看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何做好决策 </tag>
            
            <tag> 好书推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx应用之静态资源服务器</title>
      <link href="/2022/11/12/Nginx%E4%BD%9C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/11/12/Nginx%E4%BD%9C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx作静态资源服务器"><a href="#Nginx作静态资源服务器" class="headerlink" title="Nginx作静态资源服务器"></a>Nginx作静态资源服务器</h1><h2 id="静态资源准备"><a href="#静态资源准备" class="headerlink" title="静态资源准备"></a>静态资源准备</h2><p>假设现在有一个静态资源文件夹blog，将文件夹blog放在nginx安装目录中的<strong>sbin同级</strong>目录下</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改<strong>conf</strong>目录中的nginx.conf文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /&#123;</span><br><span class="line"><span class="attribute">alias</span> blog/;</span><br><span class="line">    <span class="attribute">index</span> index.html;</span><br><span class="line"><span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p><code>alias</code>与<code>root</code>作用相同，都是用来指定资源跟路径</p><p><code>index</code> 设置默认的<strong>访问首页</strong></p><p><code>autoindex</code> 选项为<code>on</code>时可以让用户浏览对应目录下所有的资源内容，如果浏览时想要<strong>下载</strong>，在<code>http</code>段加上<code>default_type application/octet-stream;</code> 如果想要<strong>查看内容</strong>，加上<code>default_type text/plain;</code></p><h2 id="重启nginx服务"><a href="#重启nginx服务" class="headerlink" title="重启nginx服务"></a>重启nginx服务</h2><p>进入到<code>sbin</code>目录下，使用命令 <code>./nginx -c /xxx/nginx.conf -s reload</code> <strong>重启</strong>nginx服务</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高性能IO模型</title>
      <link href="/2022/11/12/Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/11/12/Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis高性能IO模型"><a href="#Redis高性能IO模型" class="headerlink" title="Redis高性能IO模型"></a>Redis高性能IO模型</h3><h4 id="关于Redis单线程"><a href="#关于Redis单线程" class="headerlink" title="关于Redis单线程"></a>关于Redis单线程</h4><p>Redis的网络IO和键值对读写都是由一个线程来完成的，这也是Redis对外提供键值服务的主要流程。但Redis的其他功能，比如：持久化、异步删除、集群数据同步等功能都需要额外的线程去完成。</p><h4 id="为什么Redis要使用单线程"><a href="#为什么Redis要使用单线程" class="headerlink" title="为什么Redis要使用单线程"></a>为什么Redis要使用单线程</h4><p>多线程下会有<strong>共享资源并发访问控制</strong>问题，会给系统带来额外的开销，从而无法提高系统的吞吐率。</p><h4 id="基本IO模型"><a href="#基本IO模型" class="headerlink" title="基本IO模型"></a>基本IO模型</h4><p>以 Get 请求为例，SimpleKV 为了处理一个 Get 请求，需要监听客户端请求（bind&#x2F;listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p><p><a href="https://imgtu.com/i/jsidZF"><img src="https://s1.ax1x.com/2022/07/10/jsidZF.md.jpg" alt="jsidZF.md.jpg"></a></p><p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p><h4 id="基于多路复用的Redis-IO模型"><a href="#基于多路复用的Redis-IO模型" class="headerlink" title="基于多路复用的Redis IO模型"></a>基于多路复用的Redis IO模型</h4><p>Linux系统中的IO多路复用模型是指一个线程可以处理多个IO流，即select&#x2F;epoll机制。它允许Linux内核同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字的连接请求或者数据请求，一旦有请求到达，就会交给Redis处理，这样就实现了一个Redis线程处理多个IO流的效果。</p><p>下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p><p><a href="https://imgtu.com/i/jseykT"><img src="https://s1.ax1x.com/2022/07/10/jseykT.md.jpg" alt="jseykT.md.jpg"></a></p><p>为了在请求到达时能通知到 Redis 线程，select&#x2F;epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化之AOF</title>
      <link href="/2022/11/12/Redis-AOF/"/>
      <url>/2022/11/12/Redis-AOF/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis-AOF日志"><a href="#Redis-AOF日志" class="headerlink" title="Redis AOF日志"></a>Redis AOF日志</h3><h4 id="AOF日志实现过程"><a href="#AOF日志实现过程" class="headerlink" title="AOF日志实现过程"></a>AOF日志实现过程</h4><p>先执行客户端命令，将数据写入内存，再记录日志文件。</p><h4 id="AOF日志内容"><a href="#AOF日志内容" class="headerlink" title="AOF日志内容"></a>AOF日志内容</h4><p>以一条客户端命令 <code>set testKey testValue</code>为例，AOF日志内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="variable">$3</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"><span class="variable">$7</span></span><br><span class="line">testKey</span><br><span class="line"><span class="variable">$9</span></span><br><span class="line">testValue</span><br></pre></td></tr></table></figure><p>其中，<code>*3</code>表示当前命令由3个部分组成，$ 数字 表示这部分命令、健、值占多少字节</p><blockquote><p>为了避免额外开销，Redis在向AOF里面记录日志的时候，并不会先去对这些命令进行语法检查，所以，如果先记日志，再执行命令的话，日志中就有可能记录了错误的命令，在恢复数据的时候就有可能出错。</p></blockquote><p>因此Redis的这种先执行命令再记录日志的方式可以避免出现记录错误命令的情况。</p><p>AOF另一个好处就是先执行完命令之后才去记录日志，不会阻塞当前的写操作。</p><h4 id="AOF潜在的风险"><a href="#AOF潜在的风险" class="headerlink" title="AOF潜在的风险"></a>AOF潜在的风险</h4><p>先执行命令，后记录日志。如果在命令执行后就宕机了，那么这部分命令便无法被记录在日志中，会造成数据丢失。</p><p>AOF操作也是在主线程中进行的，如果将日志文件写入磁盘时，磁盘压力大，可能会阻塞下一个写操作。</p><h4 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h4><blockquote><p>AOF配置项appendfsync的三个可选值</p></blockquote><ul><li><strong>Always</strong> 客户端每个写命令执行完，立马同步写回磁盘</li><li><strong>Everysec</strong> 客户端每个写命令执行完，先把日志写到AOF文件的内存缓存区，每隔1秒将内存缓冲区的内容写入到磁盘</li><li><strong>No</strong> 客户端每个写命令执行完，先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写入到磁盘</li></ul><h4 id="日志文件太大怎么办"><a href="#日志文件太大怎么办" class="headerlink" title="日志文件太大怎么办"></a>日志文件太大怎么办</h4><blockquote><p>如果日志文件太大，系统恢复时Redis要执行大量命令，整个恢复过程就会非常慢。</p></blockquote><p>Redis通过<strong>AOF重写机制</strong> 来减小日志文件。在重写时，通过读取旧的命令，在一个key值被修改多次以后，Redis会记录该值最新的状态，因此会把原来的文件变小。同时，和AOF日志由主线程写回不同，AOF重写过程是由后台子进程 bgrewriteaof 来完成的。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot理解</title>
      <link href="/2022/11/12/springboot/"/>
      <url>/2022/11/12/springboot/</url>
      
        <content type="html"><![CDATA[<h3 id="1-spring-boot-starter"><a href="#1-spring-boot-starter" class="headerlink" title="1. spring-boot-starter"></a>1. spring-boot-starter</h3><blockquote><p>  决定一个项目是否为SpringBoot项目的关键是看是否集成了spring-boot-starter-parent。</p></blockquote><h4 id="1-1-spring-boot-starter-parent"><a href="#1-1-spring-boot-starter-parent" class="headerlink" title="1.1 spring-boot-starter-parent"></a>1.1 spring-boot-starter-parent</h4><p>spring-boot-starter-parent中提前配置好了常见第三方组件的版本号，方便直接引用，若遇到需要指定版本的场景，推荐使用如下方法指定版本：</p><ol><li>查询spring-boot-depedencies中该依赖的标签名；</li><li>在当前项目中重写该配置项。</li></ol><h4 id="1-2-starter的一些默认配置"><a href="#1-2-starter的一些默认配置" class="headerlink" title="1.2 starter的一些默认配置"></a>1.2 starter的一些默认配置</h4><blockquote><p>  SpringBoot提供了大量的官方starter，供开发者使用，其命名方式spring-boot-starter-<em>，若要自定义starter，官方推荐命名为</em>-spring-boot-starter</p></blockquote><p>无论是官方starter还是第三方starter，都要依赖于spring-boot-starter，而starter的自动装配核心依赖是spring-boot-autoconfigure。<br>SpringBoot提供了大量的开发场景下的默认配置，以达到快速开发的目的。例如：</p><ol><li>SpringBoot默认扫描启动类所造包下的所有注解，注册成为bean</li><li>SpringBoot默认servlet请求中的上传文件的最大大小是1MB</li><li>……</li></ol><blockquote><p>  这些配置的值最终都会映射到某一个类上，这些类都会被注册为bean。</p></blockquote><h3 id="2-一些核心注解"><a href="#2-一些核心注解" class="headerlink" title="2. 一些核心注解"></a>2. 一些核心注解</h3><h4 id="2-1-Configuration"><a href="#2-1-Configuration" class="headerlink" title="2.1 @Configuration"></a>2.1 @Configuration</h4><p>带有@<strong>Configuration</strong>注解的类可以看做是原生Spring中的xml配置文件，每一个带有@Bean的方法都相当于是注册了一个bean，bean名称默认是方法名，可以通过name属性指定。</p><blockquote><p>  proxyBeanMethods</p></blockquote><p><strong>proxyBeanMethods</strong>属性是配置类中较为重要的属性，也是SpringBoot实现Full&#x2F;Lite模式的关键属性。<br><strong>proxyBeanMethods</strong>含义是设置配置类是否启用代理模式，默认为true。true模式下，每次调用配置类中返回bean的方法时，都会先去容器中查找是否有当前实例，保证了实例的<strong>单例性</strong>，此时就称为Full模式；当proxyBeanMethods为false时，配置类不会开启代理模式，每次调用配置类中的方法获取bean，不进行判断，直接创建一个新的实例并返回，此时就是Lite模式。</p><blockquote><p>  俩种模式的选取建议：当配置类中的Bean没有被其他组件依赖时，使用Lite模式，加快容器启动速度，减少判断；当配置类中的bean被依赖时，使用Full模式。</p></blockquote><h4 id="2-2-Import"><a href="#2-2-Import" class="headerlink" title="2.2 @Import"></a>2.2 @Import</h4><blockquote><p>  @Import用于手动注册bean到容器中，可以添加到@SpringBootApplication(启动类)、@Configuration(配置类)、@Component(组件类)上。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>&#123;XXX1.class, XXX2.class&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-Conditional"><a href="#2-3-Conditional" class="headerlink" title="2.3 @Conditional"></a>2.3 @Conditional</h4><blockquote><p>  @Conditional含义是条件装配，Spring中提供了很多派生注解来满足不同场景下的条件装配，例如：   </p></blockquote><ul><li>@ConditionalOnBean(name&#x3D;”xxx”) 当容器中存在指定名称的bean实例时，注册当前bean</li><li>@ConditionalOnMissingBean (name&#x3D;”xxx”)  当容器中不存在指定名称的bean实例时，注册当前bean</li><li>@ConditionalOnWarDeployment 当项目为war包部署时，注册当前bean</li><li>@ConditionalOnProperty 当存在某个参数时候，注册当前bean</li><li>……</li></ul><h4 id="2-4-ImportResource"><a href="#2-4-ImportResource" class="headerlink" title="2.4 @ImportResource"></a>2.4 @ImportResource</h4><blockquote><p>  @ImportResource的作用是解析原生spring中的xml配置文件，导入其中的配置信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:xxx.xml&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="2-5-ConfigurationProperties"><a href="#2-5-ConfigurationProperties" class="headerlink" title="2.5 @ConfigurationProperties"></a>2.5 @ConfigurationProperties</h4><h5 id="2-5-1-Component-ConfigurationProperties"><a href="#2-5-1-Component-ConfigurationProperties" class="headerlink" title="2.5.1 @Component+@ConfigurationProperties"></a>2.5.1 @Component+@ConfigurationProperties</h5><blockquote><p>  @ConfigurationProperties的作用是将核心配置文件配置文件中的配置信息绑定到bean中的属性，该注解只能使用在被容器管理的bean上</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXX</span> &#123;&#125;    </span><br></pre></td></tr></table></figure><h5 id="2-5-2-EnableConfigurationProperties-ConfigurationProperties"><a href="#2-5-2-EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="2.5.2 @EnableConfigurationProperties+@ConfigurationProperties"></a>2.5.2 @EnableConfigurationProperties+@ConfigurationProperties</h5><blockquote><p>  大多数场景下，SpringBoot回避免直接在某个类上加@Component注解，这时就需要第二种获取配置信息的注解，在某个类上加@ConfigurationProperties注解用于接收配置信息，在另外一个<strong>配置类</strong>上加@EnableConfigurationProperties并且指定刚刚的参数映射类，可以达到一样的效果，SpringBoot底层大量使用了这种方式，例如kafka自动配置：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.kafka&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProperties</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(KafkaTemplate.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(KafkaProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaAutoConfiguration</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-自动装配原理入门"><a href="#3-自动装配原理入门" class="headerlink" title="3. 自动装配原理入门"></a>3. 自动装配原理入门</h3><blockquote><p>  由源码可知，@SpringBootApplication是一个合成注解，其中包含的三个核心注解，实现了自动装配的功能。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><h4 id="3-1-SpringBootConfiguration"><a href="#3-1-SpringBootConfiguration" class="headerlink" title="3.1 @SpringBootConfiguration"></a>3.1 @SpringBootConfiguration</h4><blockquote><p>  源码可知，@SpringBootConfiguration其内部就是一个@Confiuration配置类，并且设置了proxyBeanMethods默认值为true；</p></blockquote><h4 id="3-2-ComponentScan"><a href="#3-2-ComponentScan" class="headerlink" title="3.2 @ComponentScan"></a>3.2 @ComponentScan</h4><blockquote><p>  包扫描注解的高级用法，引入了SpringBoot中俩个自定义的扫描器，完成了包扫描的设置。</p></blockquote><h4 id="3-3-EnableAutoConfiguration"><a href="#3-3-EnableAutoConfiguration" class="headerlink" title="3.3 @EnableAutoConfiguration"></a>3.3 @EnableAutoConfiguration</h4><blockquote><p>  @EnableAutoConfiguration是实现自动装配最核心的注解，也是一个合成注解，其内部是：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure><h5 id="3-3-1-AutoConfigurationPackage"><a href="#3-3-1-AutoConfigurationPackage" class="headerlink" title="3.3.1 @AutoConfigurationPackage"></a>3.3.1 @AutoConfigurationPackage</h5><p>@AutoConfigurationPackage内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br></pre></td></tr></table></figure><p>而Registrar源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的实际含义就是找到主启动类所在的包，扫描这个包下的所有注解，完成bean注册。</p><h5 id="3-3-2-Import-AutoConfigurationImportSelector-class"><a href="#3-3-2-Import-AutoConfigurationImportSelector-class" class="headerlink" title="3.3.2 @Import({AutoConfigurationImportSelector.class})"></a>3.3.2 @Import({AutoConfigurationImportSelector.class})</h5><blockquote><p>  引入AutoConfigurationImportSelector类，最终的导入逻辑落到了这段代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line"><span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">String[] factoryImplementationNames =</span><br><span class="line">StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">.add(factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>由此可知，SpringBoot在启动时会扫描所有jar包下的META-INF&#x2F;spring.factories文件，加载其中的配置信息，关键在于spring-boot-autoconfigure-2.6.3.jar中的META-INF&#x2F;spring.factories文件，这个文件中有一段配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>所以，综上所述，SpringBoot做的事其实就是将J2EE开发所以用到的所有解决方案整合到spring-boot-autoconfigure-2.6.3.jar中的META-INF&#x2F;spring.factories文件中，SpringBoot在容器启动时，会加载这个文件中所有配置，但是查看autoconfigure包中的源码可以发现，其中所有的配置类都是条件装配(@Conditional)，这样，只要导入了对应的starter，容器就会帮我们完成自动配置。</p><blockquote><p>  由autoconfigure包中的源码可知，SpringBoot会在底层做好所有的配置，但如果用户配置了自己的实例，则以用户的优先。</p></blockquote><p>总结：</p><blockquote><p>  SpringBoot启动时会加载所有的自动配置类(XXXAutoConfiguration),<br>  每个自动配置类会按条件进行注册，大部分配置类还会关联外部的配置项,所以SpringBoot整合的组件都可以从application.properties中获取配置信息。由此，SpringBoot既完成了自动装配，按需加载的容器实现，又极大地简化了开发配置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 开发框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker概述</title>
      <link href="/2022/11/12/Docker%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/11/12/Docker%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Docker镜像-images"><a href="#1-Docker镜像-images" class="headerlink" title="1. Docker镜像(images)"></a>1. Docker镜像(images)</h3><blockquote><p>  <strong>Docker镜像是一种轻量级、可执行的独立软件包。它包含了某个运行环境所需要的内容，包括依赖、运行时、环境变量和配置文件等。</strong></p></blockquote><h4 id="1-1-UnionFS-联合文件系统"><a href="#1-1-UnionFS-联合文件系统" class="headerlink" title="1.1 UnionFS(联合文件系统)"></a>1.1 UnionFS(联合文件系统)</h4><blockquote><p>  UnionFS是一种分层、轻量并且高性能的文件系统，它支持<strong>将文件系统的修改作为一次提交一层层的叠加</strong>，UnionFS文件系统是Docker镜像的基础。</p></blockquote><h4 id="1-2-Docker的镜像加载原理"><a href="#1-2-Docker的镜像加载原理" class="headerlink" title="1.2 Docker的镜像加载原理"></a>1.2 Docker的镜像加载原理</h4><h5 id="1-2-1-bootfs-boot-file-system"><a href="#1-2-1-bootfs-boot-file-system" class="headerlink" title="1.2.1 bootfs(boot file system)"></a>1.2.1 bootfs(boot file system)</h5><blockquote><p>  bootfs主要包含bootloader和kernel，bootloader主要是作用是引导加载kernel。<strong>bootfs是Docker镜像的最底层</strong>，当bootfs加载完成之后，Docker的内存使用权转交给了linux的内核，此时就会卸载bootfs。</p></blockquote><h5 id="1-2-2-rootfs-root-file-system"><a href="#1-2-2-rootfs-root-file-system" class="headerlink" title="1.2.2 rootfs(root file system)"></a>1.2.2 rootfs(root file system)</h5><blockquote><p>  rootfs在bootfs之上，包含了典型linux系统中的标准目录和文件，例如&#x2F;usr &#x2F;etc &#x2F;dev等，相当于实现了一个<strong>精简版的发行版linux系统</strong>，例如Ubuntu、CentOS等。</p></blockquote><p>  对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，底层直接使用宿主机host的kernel，这就是Docker镜像可以做到很小的原因。并且Docker镜像的分层文件系统的每一层都可以进行资源共享。</p><p>  另外需要注意的是，<strong>Docker镜像的文件层都是只读的</strong>，当Docker容器启动时，一个新的可写层会被加载到镜像的顶部，这一层通常称为“容器层”，容器层的下层都称为“镜像层”。</p><h3 id="2-容器数据卷-volume"><a href="#2-容器数据卷-volume" class="headerlink" title="2. 容器数据卷(volume)"></a>2. 容器数据卷(volume)</h3><blockquote><p>  卷的设计目的就是容器的数据持久化和数据共享，独立在容器的生命周期之外，Docker不会在删除容器时删除其挂载的数据卷。</p></blockquote><h4 id="2-1-数据卷挂载的命令"><a href="#2-1-数据卷挂载的命令" class="headerlink" title="2.1 数据卷挂载的命令"></a>2.1 数据卷挂载的命令</h4><p>启动容器时挂载数据卷的命令：</p><pre><code>docker run -v /宿主机路径:/容器内路径 镜像名</code></pre><p>例如：</p><pre><code>docker run -v /docker-volume/redis:/volume redis</code></pre><p>启动容器时挂载<strong>只读</strong>数据卷的命令：</p><pre><code>docker run -v /宿主机路径:/容器内路径:ro 镜像名</code></pre><p>例如：</p><pre><code>docker run -v /docker-volume/redis:/volume:ro redis</code></pre><p>挂载了只读数据卷后，容器对卷只有读权限，没有写权限。</p><h4 id="2-2-DockerFile中挂载卷"><a href="#2-2-DockerFile中挂载卷" class="headerlink" title="2.2 DockerFile中挂载卷"></a>2.2 DockerFile中挂载卷</h4><p>编写DockerFile如下，文件名为volume-test</p><pre><code>#volume testFROM centos:latestVOLUME [&quot;/volume1&quot;,&quot;/volume2&quot;]CMD echo &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;docker started&quot;CMD /bin/bash</code></pre><p>执行命令</p><pre><code>docker build -f /xxx/xxx/volume-test -t hic/ctos .-f 表示指定DockerFile-t 不知道啥意思，后边跟镜像名称最后的 . 也没明白啥意思</code></pre><p>执行后会在本地构建好镜像hic&#x2F;ctos，之后启动该镜像，启动好以后用inspect命令查看镜像详细信息，信息中包含如下：</p><pre><code>&quot;Mounts&quot;: [        &#123;            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;7eb57a72c7c541caae610a5b36e4ba7974369dc929930ee26747f7511b896a96&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/7eb57a72c7c541caae610a5b36e4ba7974369dc929930ee26747f7511b896a96/_data&quot;,            &quot;Destination&quot;: &quot;/volume1&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        &#125;,        &#123;            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;f40e01c85d4c9675fad55cbb903b7c3f40841d6a6ed1d46fd8bbf4f4934b07fb&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/f40e01c85d4c9675fad55cbb903b7c3f40841d6a6ed1d46fd8bbf4f4934b07fb/_data&quot;,            &quot;Destination&quot;: &quot;/volume2&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        &#125;    ],</code></pre><p>可以看到，容器已经挂载了volume1、volume2俩个卷。</p><h4 id="2-3-2-3-数据卷的传递和共享-volumes-from"><a href="#2-3-2-3-数据卷的传递和共享-volumes-from" class="headerlink" title="2.3 2.3 数据卷的传递和共享(volumes-from)"></a>2.3 2.3 数据卷的传递和共享(volumes-from)</h4><p>还是之前的镜像hic&#x2F;ctos</p><pre><code>#volume testFROM centos:latestVOLUME [&quot;/volume1&quot;,&quot;/volume2&quot;]CMD echo &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;docker started&quot;CMD /bin/bash</code></pre><p>启动该镜像，命名为dc01</p><pre><code>docker run -it --name dc01 hic/ctos</code></pre><p>容器dc01已经成功挂载了&#x2F;volume1、&#x2F;volume2俩个卷。</p><p>再执行命令</p><pre><code>docker run -it --name dc02 --volumes-from dc01 hic/ctos    </code></pre><p> 进入容器dc02查看，发现容器内部也已经成功挂载了&#x2F;volume1、&#x2F;volume2，删除掉容器dc01后，dc02的挂载仍然生效。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/2022/11/12/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/12/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>docker images</td><td></td><td>列出本地所有镜像</td></tr><tr><td>docker images</td><td>-a</td><td>列出本地所有镜像，包含中间层</td></tr><tr><td>docker images</td><td>-q</td><td>列出本地所有镜像的ID</td></tr><tr><td>docker images</td><td>–digests</td><td>列出本地所有镜像的摘要信息</td></tr><tr><td>docker images</td><td>–digests –no-trunc</td><td>列出本地所有镜像的详细信息</td></tr><tr><td>docker search XXX</td><td></td><td>搜索镜像</td></tr><tr><td>docker pull XXX</td><td></td><td>拉取镜像，默认拉取:latest</td></tr><tr><td>docker pull XXX:[tag]</td><td></td><td>拉取制定标签镜像</td></tr><tr><td>docker rmi XXX:[tag]</td><td></td><td>删除镜像</td></tr><tr><td>docker run</td><td></td><td>运行容器</td></tr><tr><td>docker run</td><td>–name&#x3D;”xxx”</td><td>运行容器同时指定名称</td></tr><tr><td>docker run</td><td>-d</td><td>后台运行容器，并返回容器ID</td></tr><tr><td>docker run</td><td>-i</td><td>以交互模式运行容器，通常与-t同时使用</td></tr><tr><td>docker run</td><td>-t</td><td>为容器分配一个伪终端，通常与-i同时使用</td></tr><tr><td>docker run</td><td>-P</td><td>随机端口映射</td></tr><tr><td>docker run</td><td>-p</td><td>指定端口映射，有4种格式，最常用的是host_port:container_port</td></tr><tr><td>docker ps</td><td></td><td>列出当前运行的所有容器</td></tr><tr><td>docker ps</td><td>-a</td><td>列出当前运行的所有容器+历史运行过的</td></tr><tr><td>docker ps</td><td>-l</td><td>列出最近创建的容器</td></tr><tr><td>docker ps</td><td>-n <x></td><td>列出最近n个创建的容器</td></tr><tr><td>docker ps</td><td>-q</td><td>静默模式，只显示容器编号</td></tr><tr><td>docker restart XXX</td><td></td><td>重启容器</td></tr><tr><td>docker stop XXX</td><td></td><td>停止容器</td></tr><tr><td>docker restart XXX</td><td></td><td>强制停止容器</td></tr><tr><td>docker logs XXX</td><td></td><td>查看容器日志</td></tr><tr><td>docker logs</td><td>-f</td><td>跟随最新的日志</td></tr><tr><td>docker logs</td><td>-t</td><td>日志增加时间戳</td></tr><tr><td>docker logs</td><td>–tail <x></td><td>查看最后x行日志</td></tr><tr><td>docker top XXX</td><td></td><td>查看容器内部运行的进程</td></tr><tr><td>docker inspect XXX</td><td></td><td>查看容器详细信息</td></tr><tr><td>docker attacth XXX</td><td></td><td>直接进入容器终端，不会启动新的进程</td></tr><tr><td>docker exec XXX</td><td></td><td>在容器中打开新的终端，并且可以启动新的进程</td></tr><tr><td>docker cp &#x2F;xxx <container>:&#x2F;xxx</td><td></td><td>宿主机往容器中拷贝文件</td></tr><tr><td>docker cp <container>:&#x2F;xxx &#x2F;xxx</td><td></td><td>容器中往宿主机拷贝文件</td></tr><tr><td>docker commit XXX</td><td></td><td>提交容器副本使之成为一个新的镜像</td></tr></tbody></table><p>docker commit命令演示</p><blockquote><p>  docker commit -m&#x3D;”描述信息” -a&#x3D;”作者” container_id 镜像名字:[标签名]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerFile</title>
      <link href="/2022/11/12/DockerFile%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/11/12/DockerFile%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DockerFile"><a href="#1-DockerFile" class="headerlink" title="1. DockerFile"></a>1. DockerFile</h3><blockquote><p>​DockerFile是用来构建Docker镜像的的构建文件，是由一系列命令和参数组成的脚本。</p></blockquote><h4 id="1-1-DockerFile内容基础"><a href="#1-1-DockerFile内容基础" class="headerlink" title="1.1 DockerFile内容基础"></a>1.1 DockerFile内容基础</h4><ol><li>每条<strong>Docker指令</strong>都必须大写，并且后变最少跟随一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ol><h4 id="1-2-DockerFile指令详解"><a href="#1-2-DockerFile指令详解" class="headerlink" title="1.2 DockerFile指令详解"></a>1.2 DockerFile指令详解</h4><ol><li>FROM 指定当前镜像是基于哪个镜像的</li><li>MAINTAINER 镜像维护者的姓名和邮箱地址</li><li>RUN 容器构建时要运行的命令</li><li>EXPOSE 容器启动后对外暴露出的端口</li><li>WORKDIR 指定容器启动后，终端登录进来默认的路径</li><li>ENV 用于在构建镜像的过程中设置环境变量</li><li>ADD 将宿主机中的文件复制到容器并且自动处理URL和tar包解压</li><li>COPY</li><li>VOLUMES 容器数据卷，用于挂载数据卷</li><li>CMD 指定容器启动时要运行的命令，DockerFile中只有最后一个CMD会生效，并且会被run参数替换</li><li>ENTRYPOINT 指定容器启动时候要运行的命令</li><li>ONBUILD 当前镜像被继承时要执行的命令，即父镜像被子镜像继承，子镜像构建时会触发父镜像的ONBUILD指令</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作手册</title>
      <link href="/2022/11/12/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
      <url>/2022/11/12/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="git操作手册"><a href="#git操作手册" class="headerlink" title="git操作手册"></a>git操作手册</h1><p>查看<strong>本地</strong>所有分支</p><p><code>git branch</code></p><p>查看<strong>远程</strong>仓库所有分支</p><p><code>git branch -a</code></p><p>将远程仓库里的指定分支拉取到本地（本地不存在的分支）</p><p><code>git checkout -b 本地分支名 origin/远程分支名</code></p><p>这样在本地会自动创建一个新分支，并与指定的远程分支关联起来，并且会自动切换到该本地分支</p><p>如果出现以下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#x27;dev2&#x27; at the same time.</span><br><span class="line">Did you intend to checkout &#x27;origin/dev2&#x27; which can not be resolved as commit?</span><br></pre></td></tr></table></figure><p>表示拉取不成功，先执行<code>git fetch</code>，再执行上述代码即可</p><p>切换到其他分支</p><p><code>git checkout 分支名</code></p><p>拉取<strong>最新</strong>的信息</p><p><code>git pull</code></p><p>查看其他人的推送记录</p><p><code>git log</code></p><p>提交修改后的文件</p><p><code>git commit -am &#39;提交记录&#39;</code></p><p>将提交推送至远程仓库</p><p><code>git push</code></p><p>为当前仓库设置提交作者的姓名和邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;xxx&quot;</span><br><span class="line">git config user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure><p>将指定分支合并到当前分支</p><p><code>git merge 分支名</code></p><p>删除<strong>远程</strong>分支</p><ol><li>同步远程分支信息 <code>git fetch -p origin</code></li><li>删除对应分支 <code>git push origin --delete 分支名</code></li></ol><p>删除本地分支</p><p><code>git branch -d 分支名</code></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法入门</title>
      <link href="/2022/11/12/Typora%E5%85%A5%E9%97%A8/"/>
      <url>/2022/11/12/Typora%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法入门"><a href="#Markdown语法入门" class="headerlink" title="Markdown语法入门"></a>Markdown语法入门</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题一共有6级，用#和空格实现，标题前面一个#代表一级标题，两个#代表二级标题，以此类推，最多可以加六个#代表六级标题</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>在要强调的内容前后各加两个<em>即表示强调，举例：*<em>这是要强调的内容</em></em></p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>在需要用斜体表示的内容前后各加一个* <em>表示斜体</em></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>在需要删除的内容前后加两个~表示删除，举例：<del>需要删除的内容</del></p><h2 id="list列表处理"><a href="#list列表处理" class="headerlink" title="list列表处理"></a>list列表处理</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>输入数字1和.和空格，自动开始有序列表，shift加Tab退出有序列表</p><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>输入+或-或*和空格，自动开始无序列表</p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><h2 id="Table表格"><a href="#Table表格" class="headerlink" title="Table表格"></a>Table表格</h2><p>Ctrl加T，在弹出的表格中选择行数和列数</p><table><thead><tr><th>value</th><th>value</th><th>value</th></tr></thead><tbody><tr><td>value</td><td>value</td><td>value</td></tr></tbody></table><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>输入三个或三个以上-或*后按回车，即可出现分割线</p><hr><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>直接将图片拖入即可</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[链接提示]+(链接地址)，举例：<a href="https://www.baidu.com/">百度</a></p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>$$加回车<br>$$<br>y &#x3D; 2x ^ 2 + 3x^3;<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>代码的两端各加一个&#96;</p><p>举例：这是一个行内代码   <code>System.out.print(&quot;Hello World!&quot;);</code></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>输入三个~后按回车即可出现代码块编辑器然后选择编程语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h2><p>可以导出pdf或者html格式的文件</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/07/hello-world/"/>
      <url>/2022/11/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
