<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些非常实用的Java小工具</title>
      <link href="/2023/06/15/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E7%9A%84Java%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/06/15/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E7%9A%84Java%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="总结一些非常实用的Java小工具"><a href="#总结一些非常实用的Java小工具" class="headerlink" title="总结一些非常实用的Java小工具"></a>总结一些非常实用的Java小工具</h3><h4 id="对象list根据对象的某个属性去重"><a href="#对象list根据对象的某个属性去重" class="headerlink" title="对象list根据对象的某个属性去重"></a>对象list根据对象的某个属性去重</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">businessProcesses = businessProcesses</span><br><span class="line">                            .stream()</span><br><span class="line">                            .collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(BusinessProcess::getProcessId))), ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 如何获取jar包里面的resource资源文件</title>
      <link href="/2023/06/13/Springboot%20%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96jar%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
      <url>/2023/06/13/Springboot%20%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96jar%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Springboot-如何获取jar包里面的resource资源文件"><a href="#Springboot-如何获取jar包里面的resource资源文件" class="headerlink" title="Springboot 如何获取jar包里面的resource资源文件"></a>Springboot 如何获取jar包里面的resource资源文件</h3><blockquote><p><em>需求：在项目开发中，有时候需要把一些模板文件及静态资源文件放到resource目录中，并且在服务启动的时候去访问这些文件。</em></p></blockquote><p>问题：在本地开发环境中，通过读取对应的文件路径可以正常访问到，但是打成jar包以后，无法通过路径的方式读取到对应文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath();</span><br></pre></td></tr></table></figure><blockquote><p>上述代码在本地没有问题，服务器会报<strong>FileNotFound！</strong></p></blockquote><p>解决方案：</p><p>读取jar里面的静态资源文件时不要使用路径，使用<strong>文件流</strong>读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;&quot;</span>).getInputStream();</span><br></pre></td></tr></table></figure><p>如果需要处理文件，直接用文件流处理，如果必须要通过路径读文件，可以用文件流将文件写入到服务器的目录下，然后再通过路径去读取。</p><p>附上将文件流写入到本地的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将InputStream流写入到本地</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetPath 目标路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeToLocal</span><span class="params">(String targetPath, InputStream inputStream)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetPath);</span><br><span class="line">        <span class="keyword">while</span> ((index = inputStream.read(bytes)) != -<span class="number">1</span>)  &#123;</span><br><span class="line">            fileOutputStream.write(bytes, <span class="number">0</span>, index);</span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 开发遇到的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot与JDK版本对应关系</title>
      <link href="/2023/05/30/SpringBoot%E3%80%81JDK%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/05/30/SpringBoot%E3%80%81JDK%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot版本标识的含义"><a href="#SpringBoot版本标识的含义" class="headerlink" title="SpringBoot版本标识的含义"></a>SpringBoot版本标识的含义</h3><ol><li>CURRENT：代表了当前版本，最新发布版本，里程碑版本</li><li>GA：通用正式发布版本，同release</li><li>SNAPSHOT：快照版本，可用但非稳定版本</li><li>PRE：预览版本</li><li>RC：(Release　Candidate) 软件选版本。系统平台上的发行候选版本。RC版不会再加入新的功能了，主要着重于除错</li><li>Alpha：测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li><li>Beta：测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li></ol><p><a href="https://imgse.com/i/p9jjeDP"><img src="https://s1.ax1x.com/2023/05/30/p9jjeDP.png" alt="p9jjeDP.png"></a></p><p><a href="https://imgse.com/i/p9jjcb6"><img src="https://s1.ax1x.com/2023/05/30/p9jjcb6.png" alt="p9jjcb6.png"></a></p><h3 id="版本对应关系"><a href="#版本对应关系" class="headerlink" title="版本对应关系"></a>版本对应关系</h3><table><thead><tr><th>SpringBoot</th><th>SpringFramework</th><th>JDK</th><th>Maven</th></tr></thead><tbody><tr><td>3.x.x</td><td>5.3.x</td><td>17</td><td>3.6.0+</td></tr><tr><td>2.5.x</td><td>5.3.x</td><td>16,15,11,8</td><td>3.6.0+</td></tr><tr><td>2.4.x</td><td>5.3.x</td><td>16,15,11,8</td><td>3.6.2+</td></tr><tr><td>2.3.x</td><td>5.2.x</td><td>14,13,11,8</td><td>3.5.0+</td></tr><tr><td>2.2.x</td><td>5.2.x</td><td>13,12,11,8</td><td>3.3.0+</td></tr><tr><td>2.1.x</td><td>5.1.x</td><td>11,8</td><td>3.3.0+</td></tr><tr><td>2.0.x</td><td>5.0.x</td><td>9,8</td><td>3.3.0+</td></tr><tr><td>1.5.x</td><td>4.3.x</td><td>8</td><td>3.3.0+</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis中xml文件参数为map时高级用法</title>
      <link href="/2023/03/05/MyBatis%E4%B8%ADXML%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E4%B8%BAmap%E6%97%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2023/03/05/MyBatis%E4%B8%ADXML%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E4%B8%BAmap%E6%97%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="MyBatis中xml文件参数为map时高级用法"><a href="#MyBatis中xml文件参数为map时高级用法" class="headerlink" title="MyBatis中xml文件参数为map时高级用法"></a>MyBatis中xml文件参数为map时高级用法</h3><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><p><strong>下面是使用场景</strong></p><blockquote><p>假设前端将许多的参数以Vo的形式传入，我们在Service蹭、Mapper层都传入Vo，我们在xml中就需要对多个查询参数进行判空，比如下面这样：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">&quot;testXml&quot;</span> <span class="attr">paramsType</span> = <span class="string">&quot;xxx.xxx.Vo&quot;</span> <span class="attr">resultType</span> = <span class="string">&quot;xxx.xxx.Vo&quot;</span>&gt;</span></span><br><span class="line">    select xxx</span><br><span class="line">    from db.table</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;null != param1&quot;</span>&gt;</span></span><br><span class="line">            xxx = #&#123;xxx&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;null != param2&quot;</span>&gt;</span></span><br><span class="line">            xxx = #&#123;xxx&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式实现没有问题，但是有一个小小的弊端就是如果查询参数很多的话，那就要写很多很多的if标签，那么有没有一种类似于循环判断的方式从而不用写那么多if呢？当然有！</p><p>在Service层里面将Vo转成Map后传入Mapper层即可，具体实现如下：</p><p><strong>这是Service层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;UserDepte&gt; <span class="title function_">getByMap</span><span class="params">(UserQueryParams params)</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; paramsMap= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        paramsMap.put(<span class="string">&quot;key&quot;</span>, params.getXxx());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getByMap(paramsMap);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是Mapper层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getByMap</span><span class="params">(<span class="meta">@param(&quot;paramsMap&quot;)</span> Map&lt;String,Object&gt; map)</span></span><br></pre></td></tr></table></figure><p><strong>这是对应的XML文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;paramsMap.keys&quot;</span> <span class="attr">item</span>=<span class="string">&quot;k&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;null != paramsMap[k]&quot;</span>&gt;</span>    </span><br><span class="line">        $&#123;k&#125; = #&#123;paramsMap[$&#123;k&#125;]&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>   </span><br></pre></td></tr></table></figure><blockquote><p>这样就一个循环解决参数判空的问题，而不再需要写一堆if</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java使用OKHttp进行文件上传</title>
      <link href="/2023/03/05/Java%E4%BD%BF%E7%94%A8OKHttp%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/03/05/Java%E4%BD%BF%E7%94%A8OKHttp%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Java使用OKHttp进行文件上传"><a href="#Java使用OKHttp进行文件上传" class="headerlink" title="Java使用OKHttp进行文件上传"></a>Java使用OKHttp进行文件上传</h3><p>使用场景：服务端使用<strong>InputStream</strong>来接收文件</p><p>客户端使用<strong>post</strong>请求</p><p><strong>headerMap</strong>用于存放<strong>请求头</strong>信息</p><p><strong>paramsMap</strong>用于存放<strong>文件</strong>和<strong>字符串</strong>参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postFile</span><span class="params">(String url, HashMap&lt;String, String&gt; headerMap, HashMap&lt;String, Object&gt; paramsMap)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"></span><br><span class="line">        MultipartBody.<span class="type">Builder</span> <span class="variable">builder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartBody</span>.Builder();</span><br><span class="line">        builder1.setType(MultipartBody.FORM);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; stringObjectEntry : paramsMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringObjectEntry.getKey();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> stringObjectEntry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> File) &#123;<span class="comment">//如果请求的值是文件</span></span><br><span class="line">                <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> (File) value;</span><br><span class="line">                <span class="comment">//MediaType.parse(&quot;application/octet-stream&quot;)以二进制的形式上传文件</span></span><br><span class="line">                builder1.addFormDataPart(<span class="string">&quot;file&quot;</span>, ((File) value).getName(), RequestBody.create(MediaType.parse(<span class="string">&quot;multipart/form-data&quot;</span>), file));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果请求的值是string类型</span></span><br><span class="line">                builder1.addFormDataPart(key, value.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Request.<span class="type">Builder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder();</span><br><span class="line">        requestBuilder.url(url);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加请求头</span></span><br><span class="line">        <span class="keyword">if</span>(CollectionUtil.isNotEmpty(headerMap))&#123;</span><br><span class="line">            Set&lt;String&gt; keys = headerMap.keySet();</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> headerMap.get(key);</span><br><span class="line">                requestBuilder.addHeader(key, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        requestBuilder.post(builder1.build()).url(url);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> requestBuilder.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="type">ResponseBody</span> <span class="variable">responseBody</span> <span class="operator">=</span> response.body();</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(responseBody)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;响应体为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">strResponse</span> <span class="operator">=</span> responseBody.string();</span><br><span class="line">            log.info(<span class="string">&quot;打印响应参数:&#123;&#125;&quot;</span>, strResponse);</span><br><span class="line">            <span class="keyword">return</span> strResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端支持上传多个文件，paramsMap中的value设置为File类型的文件即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设现在有多个list：List&lt;File&gt; files</span></span><br><span class="line">Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 字符串类型参数正常设置即可</span></span><br><span class="line">paramsMap.put(<span class="string">&quot;StringKey&quot;</span>, <span class="string">&quot;StringValue&quot;</span>);</span><br><span class="line"><span class="comment">// 文件类型参数设置方式如下：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">    paramsMap.put(<span class="string">&quot;file&quot;</span>+i, files.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java使用httpClient进行文件上传</title>
      <link href="/2023/03/05/Java%E4%BD%BF%E7%94%A8httpClient%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/03/05/Java%E4%BD%BF%E7%94%A8httpClient%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Java使用httpClient进行文件上传"><a href="#Java使用httpClient进行文件上传" class="headerlink" title="Java使用httpClient进行文件上传"></a>Java使用httpClient进行文件上传</h3><p>使用场景：服务端使用<strong>InputStream</strong>来接收文件</p><p>客户端使用<strong>post</strong>请求</p><p>fileNameWithSuffix表示<strong>带后缀</strong>的文件名，例如test.txt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postFile</span><span class="params">(String url, String token, String fileNameWithSuffix, InputStream inputStream)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">        httpPost.setHeader(<span class="string">&quot;Authorization&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">        <span class="type">MultipartEntityBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> MultipartEntityBuilder.create();</span><br><span class="line">        builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);</span><br><span class="line">        builder.addBinaryBody(<span class="string">&quot;file&quot;</span>, inputStream, ContentType.create(<span class="string">&quot;multipart/form-data&quot;</span>), fileNameWithSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> builder.build();</span><br><span class="line">        httpPost.setEntity(entity);</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CloseableHttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != httpResponse) &#123;</span><br><span class="line">                <span class="type">HttpEntity</span> <span class="variable">responseEntity</span> <span class="operator">=</span> httpResponse.getEntity();</span><br><span class="line">                <span class="type">String</span> <span class="variable">responseStr</span> <span class="operator">=</span> EntityUtils.toString(responseEntity, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                log.info(<span class="string">&quot;打印响应信息:&#123;&#125;&quot;</span>, responseStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读万卷书，行万里路</title>
      <link href="/2023/02/19/%E3%80%8A%E4%BA%BA%E7%94%9F%E7%AE%97%E6%B3%95%E3%80%8B/"/>
      <url>/2023/02/19/%E3%80%8A%E4%BA%BA%E7%94%9F%E7%AE%97%E6%B3%95%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="《人生算法》"><a href="#《人生算法》" class="headerlink" title="《人生算法》"></a>《人生算法》</h3><p><strong>用概率思维做好决策</strong></p><blockquote><p>想象你现在中了一个大奖，你有两个选择：直接拿走100万美元；或有50%的概率获得一亿美元，也有50%的可能什么也拿不到，你会怎么选？</p></blockquote><p><a href="https://imgse.com/i/pSLTGQA"><img src="https://s1.ax1x.com/2023/02/19/pSLTGQA.jpg" alt="pSLTGQA.jpg"></a></p><blockquote><p>多数人会选择直接拿走100万美元，因为他们不愿意承受什么都拿不到的风险。事实上如果你打开思路，把获得一亿美元的机会以2000万美元的机会卖给愿意承担风险的人，你就能赚2000万美元，而不是仅仅获得100万美元。这就是算法思维的力量，它决定了人们不一样的人生轨迹。</p></blockquote><p>​        阿西莫夫说：“科学是一个机制，是扩充你对自然的认知的一个方式。科学是一个系统，用宇宙中的事实验证你的想法是否在正确。这个系统很有效，不仅仅是在科学领域，放到日常生活中也很有用处。”人生算法的实用主义背后，正是这类验证，正如我们的一生也是某种验证一样。</p><h3 id="《图解设计模式》"><a href="#《图解设计模式》" class="headerlink" title="《图解设计模式》"></a>《图解设计模式》</h3><p><strong>194张图表轻松理解GoF的23种设计模式</strong></p><blockquote><p>作者：【日】结城浩，生于1963年，日本知名技术作家和程序员。在编程语言、设计模式、数学、加密技术等领域，编写了很多深受欢迎的入门书。代表作有《数学女孩》系列、《程序员的数学》、《图解密码技术》等。</p></blockquote><p><a href="https://imgse.com/i/ppEgbWR"><img src="https://s1.ax1x.com/2023/03/05/ppEgbWR.jpg" alt="ppEgbWR.jpg"></a></p><p>​     本书以浅显易懂的语言逐一说明了GoF的23种设计模式。在讲解过程中不仅搭配了丰富的图片，而且理论结合实例，用Java语言编写代码实现了设计模式的程序，让程序真正的运行起来，并提供了运用模式解决具体问题的练习题和答案。除此以外，本书在必要时还对Java语言的功能进行补充说明，以加深读者对Java的理解。本书适合对面向对象开发感兴趣、对设计模式感兴趣的人以及所有Java程序员阅读。</p>]]></content>
      
      
      <categories>
          
          <category> 这些书值得看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何做好决策 </tag>
            
            <tag> 好书推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx应用之静态资源服务器</title>
      <link href="/2022/11/12/Nginx%E4%BD%9C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/11/12/Nginx%E4%BD%9C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx作静态资源服务器"><a href="#Nginx作静态资源服务器" class="headerlink" title="Nginx作静态资源服务器"></a>Nginx作静态资源服务器</h1><h2 id="静态资源准备"><a href="#静态资源准备" class="headerlink" title="静态资源准备"></a>静态资源准备</h2><p>假设现在有一个静态资源文件夹blog，将文件夹blog放在nginx安装目录中的<strong>sbin同级</strong>目录下</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改<strong>conf</strong>目录中的nginx.conf文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /&#123;</span><br><span class="line"><span class="attribute">alias</span> blog/;</span><br><span class="line">    <span class="attribute">index</span> index.html;</span><br><span class="line"><span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p><code>alias</code>与<code>root</code>作用相同，都是用来指定资源跟路径</p><p><code>index</code> 设置默认的<strong>访问首页</strong></p><p><code>autoindex</code> 选项为<code>on</code>时可以让用户浏览对应目录下所有的资源内容，如果浏览时想要<strong>下载</strong>，在<code>http</code>段加上<code>default_type application/octet-stream;</code> 如果想要<strong>查看内容</strong>，加上<code>default_type text/plain;</code></p><h2 id="重启nginx服务"><a href="#重启nginx服务" class="headerlink" title="重启nginx服务"></a>重启nginx服务</h2><p>进入到<code>sbin</code>目录下，使用命令 <code>./nginx -c /xxx/nginx.conf -s reload</code> <strong>重启</strong>nginx服务</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高性能IO模型</title>
      <link href="/2022/11/12/Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/11/12/Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis高性能IO模型"><a href="#Redis高性能IO模型" class="headerlink" title="Redis高性能IO模型"></a>Redis高性能IO模型</h3><h4 id="关于Redis单线程"><a href="#关于Redis单线程" class="headerlink" title="关于Redis单线程"></a>关于Redis单线程</h4><p>Redis的网络IO和键值对读写都是由一个线程来完成的，这也是Redis对外提供键值服务的主要流程。但Redis的其他功能，比如：持久化、异步删除、集群数据同步等功能都需要额外的线程去完成。</p><h4 id="为什么Redis要使用单线程"><a href="#为什么Redis要使用单线程" class="headerlink" title="为什么Redis要使用单线程"></a>为什么Redis要使用单线程</h4><p>多线程下会有<strong>共享资源并发访问控制</strong>问题，会给系统带来额外的开销，从而无法提高系统的吞吐率。</p><h4 id="基本IO模型"><a href="#基本IO模型" class="headerlink" title="基本IO模型"></a>基本IO模型</h4><p>以 Get 请求为例，SimpleKV 为了处理一个 Get 请求，需要监听客户端请求（bind&#x2F;listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p><p><a href="https://imgtu.com/i/jsidZF"><img src="https://s1.ax1x.com/2022/07/10/jsidZF.md.jpg" alt="jsidZF.md.jpg"></a></p><p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p><h4 id="基于多路复用的Redis-IO模型"><a href="#基于多路复用的Redis-IO模型" class="headerlink" title="基于多路复用的Redis IO模型"></a>基于多路复用的Redis IO模型</h4><p>Linux系统中的IO多路复用模型是指一个线程可以处理多个IO流，即select&#x2F;epoll机制。它允许Linux内核同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字的连接请求或者数据请求，一旦有请求到达，就会交给Redis处理，这样就实现了一个Redis线程处理多个IO流的效果。</p><p>下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p><p><a href="https://imgtu.com/i/jseykT"><img src="https://s1.ax1x.com/2022/07/10/jseykT.md.jpg" alt="jseykT.md.jpg"></a></p><p>为了在请求到达时能通知到 Redis 线程，select&#x2F;epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化之AOF</title>
      <link href="/2022/11/12/Redis-AOF/"/>
      <url>/2022/11/12/Redis-AOF/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis-AOF日志"><a href="#Redis-AOF日志" class="headerlink" title="Redis AOF日志"></a>Redis AOF日志</h3><h4 id="AOF日志实现过程"><a href="#AOF日志实现过程" class="headerlink" title="AOF日志实现过程"></a>AOF日志实现过程</h4><p>先执行客户端命令，将数据写入内存，再记录日志文件。</p><h4 id="AOF日志内容"><a href="#AOF日志内容" class="headerlink" title="AOF日志内容"></a>AOF日志内容</h4><p>以一条客户端命令 <code>set testKey testValue</code>为例，AOF日志内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="variable">$3</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"><span class="variable">$7</span></span><br><span class="line">testKey</span><br><span class="line"><span class="variable">$9</span></span><br><span class="line">testValue</span><br></pre></td></tr></table></figure><p>其中，<code>*3</code>表示当前命令由3个部分组成，$ 数字 表示这部分命令、健、值占多少字节</p><blockquote><p>为了避免额外开销，Redis在向AOF里面记录日志的时候，并不会先去对这些命令进行语法检查，所以，如果先记日志，再执行命令的话，日志中就有可能记录了错误的命令，在恢复数据的时候就有可能出错。</p></blockquote><p>因此Redis的这种先执行命令再记录日志的方式可以避免出现记录错误命令的情况。</p><p>AOF另一个好处就是先执行完命令之后才去记录日志，不会阻塞当前的写操作。</p><h4 id="AOF潜在的风险"><a href="#AOF潜在的风险" class="headerlink" title="AOF潜在的风险"></a>AOF潜在的风险</h4><p>先执行命令，后记录日志。如果在命令执行后就宕机了，那么这部分命令便无法被记录在日志中，会造成数据丢失。</p><p>AOF操作也是在主线程中进行的，如果将日志文件写入磁盘时，磁盘压力大，可能会阻塞下一个写操作。</p><h4 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h4><blockquote><p>AOF配置项appendfsync的三个可选值</p></blockquote><ul><li><strong>Always</strong> 客户端每个写命令执行完，立马同步写回磁盘</li><li><strong>Everysec</strong> 客户端每个写命令执行完，先把日志写到AOF文件的内存缓存区，每隔1秒将内存缓冲区的内容写入到磁盘</li><li><strong>No</strong> 客户端每个写命令执行完，先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写入到磁盘</li></ul><h4 id="日志文件太大怎么办"><a href="#日志文件太大怎么办" class="headerlink" title="日志文件太大怎么办"></a>日志文件太大怎么办</h4><blockquote><p>如果日志文件太大，系统恢复时Redis要执行大量命令，整个恢复过程就会非常慢。</p></blockquote><p>Redis通过<strong>AOF重写机制</strong> 来减小日志文件。在重写时，通过读取旧的命令，在一个key值被修改多次以后，Redis会记录该值最新的状态，因此会把原来的文件变小。同时，和AOF日志由主线程写回不同，AOF重写过程是由后台子进程 bgrewriteaof 来完成的。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot理解</title>
      <link href="/2022/11/12/springboot/"/>
      <url>/2022/11/12/springboot/</url>
      
        <content type="html"><![CDATA[<h3 id="1-spring-boot-starter"><a href="#1-spring-boot-starter" class="headerlink" title="1. spring-boot-starter"></a>1. spring-boot-starter</h3><blockquote><p>  决定一个项目是否为SpringBoot项目的关键是看是否集成了spring-boot-starter-parent。</p></blockquote><h4 id="1-1-spring-boot-starter-parent"><a href="#1-1-spring-boot-starter-parent" class="headerlink" title="1.1 spring-boot-starter-parent"></a>1.1 spring-boot-starter-parent</h4><p>spring-boot-starter-parent中提前配置好了常见第三方组件的版本号，方便直接引用，若遇到需要指定版本的场景，推荐使用如下方法指定版本：</p><ol><li>查询spring-boot-depedencies中该依赖的标签名；</li><li>在当前项目中重写该配置项。</li></ol><h4 id="1-2-starter的一些默认配置"><a href="#1-2-starter的一些默认配置" class="headerlink" title="1.2 starter的一些默认配置"></a>1.2 starter的一些默认配置</h4><blockquote><p>  SpringBoot提供了大量的官方starter，供开发者使用，其命名方式spring-boot-starter-<em>，若要自定义starter，官方推荐命名为</em>-spring-boot-starter</p></blockquote><p>无论是官方starter还是第三方starter，都要依赖于spring-boot-starter，而starter的自动装配核心依赖是spring-boot-autoconfigure。<br>SpringBoot提供了大量的开发场景下的默认配置，以达到快速开发的目的。例如：</p><ol><li>SpringBoot默认扫描启动类所造包下的所有注解，注册成为bean</li><li>SpringBoot默认servlet请求中的上传文件的最大大小是1MB</li><li>……</li></ol><blockquote><p>  这些配置的值最终都会映射到某一个类上，这些类都会被注册为bean。</p></blockquote><h3 id="2-一些核心注解"><a href="#2-一些核心注解" class="headerlink" title="2. 一些核心注解"></a>2. 一些核心注解</h3><h4 id="2-1-Configuration"><a href="#2-1-Configuration" class="headerlink" title="2.1 @Configuration"></a>2.1 @Configuration</h4><p>带有@<strong>Configuration</strong>注解的类可以看做是原生Spring中的xml配置文件，每一个带有@Bean的方法都相当于是注册了一个bean，bean名称默认是方法名，可以通过name属性指定。</p><blockquote><p>  proxyBeanMethods</p></blockquote><p><strong>proxyBeanMethods</strong>属性是配置类中较为重要的属性，也是SpringBoot实现Full&#x2F;Lite模式的关键属性。<br><strong>proxyBeanMethods</strong>含义是设置配置类是否启用代理模式，默认为true。true模式下，每次调用配置类中返回bean的方法时，都会先去容器中查找是否有当前实例，保证了实例的<strong>单例性</strong>，此时就称为Full模式；当proxyBeanMethods为false时，配置类不会开启代理模式，每次调用配置类中的方法获取bean，不进行判断，直接创建一个新的实例并返回，此时就是Lite模式。</p><blockquote><p>  俩种模式的选取建议：当配置类中的Bean没有被其他组件依赖时，使用Lite模式，加快容器启动速度，减少判断；当配置类中的bean被依赖时，使用Full模式。</p></blockquote><h4 id="2-2-Import"><a href="#2-2-Import" class="headerlink" title="2.2 @Import"></a>2.2 @Import</h4><blockquote><p>  @Import用于手动注册bean到容器中，可以添加到@SpringBootApplication(启动类)、@Configuration(配置类)、@Component(组件类)上。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>&#123;XXX1.class, XXX2.class&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-Conditional"><a href="#2-3-Conditional" class="headerlink" title="2.3 @Conditional"></a>2.3 @Conditional</h4><blockquote><p>  @Conditional含义是条件装配，Spring中提供了很多派生注解来满足不同场景下的条件装配，例如：   </p></blockquote><ul><li>@ConditionalOnBean(name&#x3D;”xxx”) 当容器中存在指定名称的bean实例时，注册当前bean</li><li>@ConditionalOnMissingBean (name&#x3D;”xxx”)  当容器中不存在指定名称的bean实例时，注册当前bean</li><li>@ConditionalOnWarDeployment 当项目为war包部署时，注册当前bean</li><li>@ConditionalOnProperty 当存在某个参数时候，注册当前bean</li><li>……</li></ul><h4 id="2-4-ImportResource"><a href="#2-4-ImportResource" class="headerlink" title="2.4 @ImportResource"></a>2.4 @ImportResource</h4><blockquote><p>  @ImportResource的作用是解析原生spring中的xml配置文件，导入其中的配置信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:xxx.xml&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="2-5-ConfigurationProperties"><a href="#2-5-ConfigurationProperties" class="headerlink" title="2.5 @ConfigurationProperties"></a>2.5 @ConfigurationProperties</h4><h5 id="2-5-1-Component-ConfigurationProperties"><a href="#2-5-1-Component-ConfigurationProperties" class="headerlink" title="2.5.1 @Component+@ConfigurationProperties"></a>2.5.1 @Component+@ConfigurationProperties</h5><blockquote><p>  @ConfigurationProperties的作用是将核心配置文件配置文件中的配置信息绑定到bean中的属性，该注解只能使用在被容器管理的bean上</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXX</span> &#123;&#125;    </span><br></pre></td></tr></table></figure><h5 id="2-5-2-EnableConfigurationProperties-ConfigurationProperties"><a href="#2-5-2-EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="2.5.2 @EnableConfigurationProperties+@ConfigurationProperties"></a>2.5.2 @EnableConfigurationProperties+@ConfigurationProperties</h5><blockquote><p>  大多数场景下，SpringBoot回避免直接在某个类上加@Component注解，这时就需要第二种获取配置信息的注解，在某个类上加@ConfigurationProperties注解用于接收配置信息，在另外一个<strong>配置类</strong>上加@EnableConfigurationProperties并且指定刚刚的参数映射类，可以达到一样的效果，SpringBoot底层大量使用了这种方式，例如kafka自动配置：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.kafka&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProperties</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(KafkaTemplate.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(KafkaProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaAutoConfiguration</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-自动装配原理入门"><a href="#3-自动装配原理入门" class="headerlink" title="3. 自动装配原理入门"></a>3. 自动装配原理入门</h3><blockquote><p>  由源码可知，@SpringBootApplication是一个合成注解，其中包含的三个核心注解，实现了自动装配的功能。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><h4 id="3-1-SpringBootConfiguration"><a href="#3-1-SpringBootConfiguration" class="headerlink" title="3.1 @SpringBootConfiguration"></a>3.1 @SpringBootConfiguration</h4><blockquote><p>  源码可知，@SpringBootConfiguration其内部就是一个@Confiuration配置类，并且设置了proxyBeanMethods默认值为true；</p></blockquote><h4 id="3-2-ComponentScan"><a href="#3-2-ComponentScan" class="headerlink" title="3.2 @ComponentScan"></a>3.2 @ComponentScan</h4><blockquote><p>  包扫描注解的高级用法，引入了SpringBoot中俩个自定义的扫描器，完成了包扫描的设置。</p></blockquote><h4 id="3-3-EnableAutoConfiguration"><a href="#3-3-EnableAutoConfiguration" class="headerlink" title="3.3 @EnableAutoConfiguration"></a>3.3 @EnableAutoConfiguration</h4><blockquote><p>  @EnableAutoConfiguration是实现自动装配最核心的注解，也是一个合成注解，其内部是：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure><h5 id="3-3-1-AutoConfigurationPackage"><a href="#3-3-1-AutoConfigurationPackage" class="headerlink" title="3.3.1 @AutoConfigurationPackage"></a>3.3.1 @AutoConfigurationPackage</h5><p>@AutoConfigurationPackage内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br></pre></td></tr></table></figure><p>而Registrar源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的实际含义就是找到主启动类所在的包，扫描这个包下的所有注解，完成bean注册。</p><h5 id="3-3-2-Import-AutoConfigurationImportSelector-class"><a href="#3-3-2-Import-AutoConfigurationImportSelector-class" class="headerlink" title="3.3.2 @Import({AutoConfigurationImportSelector.class})"></a>3.3.2 @Import({AutoConfigurationImportSelector.class})</h5><blockquote><p>  引入AutoConfigurationImportSelector类，最终的导入逻辑落到了这段代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line"><span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">String[] factoryImplementationNames =</span><br><span class="line">StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">.add(factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>由此可知，SpringBoot在启动时会扫描所有jar包下的META-INF&#x2F;spring.factories文件，加载其中的配置信息，关键在于spring-boot-autoconfigure-2.6.3.jar中的META-INF&#x2F;spring.factories文件，这个文件中有一段配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>所以，综上所述，SpringBoot做的事其实就是将J2EE开发所以用到的所有解决方案整合到spring-boot-autoconfigure-2.6.3.jar中的META-INF&#x2F;spring.factories文件中，SpringBoot在容器启动时，会加载这个文件中所有配置，但是查看autoconfigure包中的源码可以发现，其中所有的配置类都是条件装配(@Conditional)，这样，只要导入了对应的starter，容器就会帮我们完成自动配置。</p><blockquote><p>  由autoconfigure包中的源码可知，SpringBoot会在底层做好所有的配置，但如果用户配置了自己的实例，则以用户的优先。</p></blockquote><p>总结：</p><blockquote><p>  SpringBoot启动时会加载所有的自动配置类(XXXAutoConfiguration),<br>  每个自动配置类会按条件进行注册，大部分配置类还会关联外部的配置项,所以SpringBoot整合的组件都可以从application.properties中获取配置信息。由此，SpringBoot既完成了自动装配，按需加载的容器实现，又极大地简化了开发配置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 开发框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker概述</title>
      <link href="/2022/11/12/Docker%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/11/12/Docker%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Docker镜像-images"><a href="#1-Docker镜像-images" class="headerlink" title="1. Docker镜像(images)"></a>1. Docker镜像(images)</h3><blockquote><p>  <strong>Docker镜像是一种轻量级、可执行的独立软件包。它包含了某个运行环境所需要的内容，包括依赖、运行时、环境变量和配置文件等。</strong></p></blockquote><h4 id="1-1-UnionFS-联合文件系统"><a href="#1-1-UnionFS-联合文件系统" class="headerlink" title="1.1 UnionFS(联合文件系统)"></a>1.1 UnionFS(联合文件系统)</h4><blockquote><p>  UnionFS是一种分层、轻量并且高性能的文件系统，它支持<strong>将文件系统的修改作为一次提交一层层的叠加</strong>，UnionFS文件系统是Docker镜像的基础。</p></blockquote><h4 id="1-2-Docker的镜像加载原理"><a href="#1-2-Docker的镜像加载原理" class="headerlink" title="1.2 Docker的镜像加载原理"></a>1.2 Docker的镜像加载原理</h4><h5 id="1-2-1-bootfs-boot-file-system"><a href="#1-2-1-bootfs-boot-file-system" class="headerlink" title="1.2.1 bootfs(boot file system)"></a>1.2.1 bootfs(boot file system)</h5><blockquote><p>  bootfs主要包含bootloader和kernel，bootloader主要是作用是引导加载kernel。<strong>bootfs是Docker镜像的最底层</strong>，当bootfs加载完成之后，Docker的内存使用权转交给了linux的内核，此时就会卸载bootfs。</p></blockquote><h5 id="1-2-2-rootfs-root-file-system"><a href="#1-2-2-rootfs-root-file-system" class="headerlink" title="1.2.2 rootfs(root file system)"></a>1.2.2 rootfs(root file system)</h5><blockquote><p>  rootfs在bootfs之上，包含了典型linux系统中的标准目录和文件，例如&#x2F;usr &#x2F;etc &#x2F;dev等，相当于实现了一个<strong>精简版的发行版linux系统</strong>，例如Ubuntu、CentOS等。</p></blockquote><p>  对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，底层直接使用宿主机host的kernel，这就是Docker镜像可以做到很小的原因。并且Docker镜像的分层文件系统的每一层都可以进行资源共享。</p><p>  另外需要注意的是，<strong>Docker镜像的文件层都是只读的</strong>，当Docker容器启动时，一个新的可写层会被加载到镜像的顶部，这一层通常称为“容器层”，容器层的下层都称为“镜像层”。</p><h3 id="2-容器数据卷-volume"><a href="#2-容器数据卷-volume" class="headerlink" title="2. 容器数据卷(volume)"></a>2. 容器数据卷(volume)</h3><blockquote><p>  卷的设计目的就是容器的数据持久化和数据共享，独立在容器的生命周期之外，Docker不会在删除容器时删除其挂载的数据卷。</p></blockquote><h4 id="2-1-数据卷挂载的命令"><a href="#2-1-数据卷挂载的命令" class="headerlink" title="2.1 数据卷挂载的命令"></a>2.1 数据卷挂载的命令</h4><p>启动容器时挂载数据卷的命令：</p><pre><code>docker run -v /宿主机路径:/容器内路径 镜像名</code></pre><p>例如：</p><pre><code>docker run -v /docker-volume/redis:/volume redis</code></pre><p>启动容器时挂载<strong>只读</strong>数据卷的命令：</p><pre><code>docker run -v /宿主机路径:/容器内路径:ro 镜像名</code></pre><p>例如：</p><pre><code>docker run -v /docker-volume/redis:/volume:ro redis</code></pre><p>挂载了只读数据卷后，容器对卷只有读权限，没有写权限。</p><h4 id="2-2-DockerFile中挂载卷"><a href="#2-2-DockerFile中挂载卷" class="headerlink" title="2.2 DockerFile中挂载卷"></a>2.2 DockerFile中挂载卷</h4><p>编写DockerFile如下，文件名为volume-test</p><pre><code>#volume testFROM centos:latestVOLUME [&quot;/volume1&quot;,&quot;/volume2&quot;]CMD echo &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;docker started&quot;CMD /bin/bash</code></pre><p>执行命令</p><pre><code>docker build -f /xxx/xxx/volume-test -t hic/ctos .-f 表示指定DockerFile-t 不知道啥意思，后边跟镜像名称最后的 . 也没明白啥意思</code></pre><p>执行后会在本地构建好镜像hic&#x2F;ctos，之后启动该镜像，启动好以后用inspect命令查看镜像详细信息，信息中包含如下：</p><pre><code>&quot;Mounts&quot;: [        &#123;            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;7eb57a72c7c541caae610a5b36e4ba7974369dc929930ee26747f7511b896a96&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/7eb57a72c7c541caae610a5b36e4ba7974369dc929930ee26747f7511b896a96/_data&quot;,            &quot;Destination&quot;: &quot;/volume1&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        &#125;,        &#123;            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;f40e01c85d4c9675fad55cbb903b7c3f40841d6a6ed1d46fd8bbf4f4934b07fb&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/f40e01c85d4c9675fad55cbb903b7c3f40841d6a6ed1d46fd8bbf4f4934b07fb/_data&quot;,            &quot;Destination&quot;: &quot;/volume2&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        &#125;    ],</code></pre><p>可以看到，容器已经挂载了volume1、volume2俩个卷。</p><h4 id="2-3-2-3-数据卷的传递和共享-volumes-from"><a href="#2-3-2-3-数据卷的传递和共享-volumes-from" class="headerlink" title="2.3 2.3 数据卷的传递和共享(volumes-from)"></a>2.3 2.3 数据卷的传递和共享(volumes-from)</h4><p>还是之前的镜像hic&#x2F;ctos</p><pre><code>#volume testFROM centos:latestVOLUME [&quot;/volume1&quot;,&quot;/volume2&quot;]CMD echo &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;docker started&quot;CMD /bin/bash</code></pre><p>启动该镜像，命名为dc01</p><pre><code>docker run -it --name dc01 hic/ctos</code></pre><p>容器dc01已经成功挂载了&#x2F;volume1、&#x2F;volume2俩个卷。</p><p>再执行命令</p><pre><code>docker run -it --name dc02 --volumes-from dc01 hic/ctos    </code></pre><p> 进入容器dc02查看，发现容器内部也已经成功挂载了&#x2F;volume1、&#x2F;volume2，删除掉容器dc01后，dc02的挂载仍然生效。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/2022/11/12/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/12/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>docker images</td><td></td><td>列出本地所有镜像</td></tr><tr><td>docker images</td><td>-a</td><td>列出本地所有镜像，包含中间层</td></tr><tr><td>docker images</td><td>-q</td><td>列出本地所有镜像的ID</td></tr><tr><td>docker images</td><td>–digests</td><td>列出本地所有镜像的摘要信息</td></tr><tr><td>docker images</td><td>–digests –no-trunc</td><td>列出本地所有镜像的详细信息</td></tr><tr><td>docker search XXX</td><td></td><td>搜索镜像</td></tr><tr><td>docker pull XXX</td><td></td><td>拉取镜像，默认拉取:latest</td></tr><tr><td>docker pull XXX:[tag]</td><td></td><td>拉取制定标签镜像</td></tr><tr><td>docker rmi XXX:[tag]</td><td></td><td>删除镜像</td></tr><tr><td>docker run</td><td></td><td>运行容器</td></tr><tr><td>docker run</td><td>–name&#x3D;”xxx”</td><td>运行容器同时指定名称</td></tr><tr><td>docker run</td><td>-d</td><td>后台运行容器，并返回容器ID</td></tr><tr><td>docker run</td><td>-i</td><td>以交互模式运行容器，通常与-t同时使用</td></tr><tr><td>docker run</td><td>-t</td><td>为容器分配一个伪终端，通常与-i同时使用</td></tr><tr><td>docker run</td><td>-P</td><td>随机端口映射</td></tr><tr><td>docker run</td><td>-p</td><td>指定端口映射，有4种格式，最常用的是host_port:container_port</td></tr><tr><td>docker ps</td><td></td><td>列出当前运行的所有容器</td></tr><tr><td>docker ps</td><td>-a</td><td>列出当前运行的所有容器+历史运行过的</td></tr><tr><td>docker ps</td><td>-l</td><td>列出最近创建的容器</td></tr><tr><td>docker ps</td><td>-n <x></td><td>列出最近n个创建的容器</td></tr><tr><td>docker ps</td><td>-q</td><td>静默模式，只显示容器编号</td></tr><tr><td>docker restart XXX</td><td></td><td>重启容器</td></tr><tr><td>docker stop XXX</td><td></td><td>停止容器</td></tr><tr><td>docker restart XXX</td><td></td><td>强制停止容器</td></tr><tr><td>docker logs XXX</td><td></td><td>查看容器日志</td></tr><tr><td>docker logs</td><td>-f</td><td>跟随最新的日志</td></tr><tr><td>docker logs</td><td>-t</td><td>日志增加时间戳</td></tr><tr><td>docker logs</td><td>–tail <x></td><td>查看最后x行日志</td></tr><tr><td>docker top XXX</td><td></td><td>查看容器内部运行的进程</td></tr><tr><td>docker inspect XXX</td><td></td><td>查看容器详细信息</td></tr><tr><td>docker attacth XXX</td><td></td><td>直接进入容器终端，不会启动新的进程</td></tr><tr><td>docker exec XXX</td><td></td><td>在容器中打开新的终端，并且可以启动新的进程</td></tr><tr><td>docker cp &#x2F;xxx <container>:&#x2F;xxx</td><td></td><td>宿主机往容器中拷贝文件</td></tr><tr><td>docker cp <container>:&#x2F;xxx &#x2F;xxx</td><td></td><td>容器中往宿主机拷贝文件</td></tr><tr><td>docker commit XXX</td><td></td><td>提交容器副本使之成为一个新的镜像</td></tr></tbody></table><p>docker commit命令演示</p><blockquote><p>  docker commit -m&#x3D;”描述信息” -a&#x3D;”作者” container_id 镜像名字:[标签名]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerFile</title>
      <link href="/2022/11/12/DockerFile%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/11/12/DockerFile%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DockerFile"><a href="#1-DockerFile" class="headerlink" title="1. DockerFile"></a>1. DockerFile</h3><blockquote><p>​DockerFile是用来构建Docker镜像的的构建文件，是由一系列命令和参数组成的脚本。</p></blockquote><h4 id="1-1-DockerFile内容基础"><a href="#1-1-DockerFile内容基础" class="headerlink" title="1.1 DockerFile内容基础"></a>1.1 DockerFile内容基础</h4><ol><li>每条<strong>Docker指令</strong>都必须大写，并且后变最少跟随一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ol><h4 id="1-2-DockerFile指令详解"><a href="#1-2-DockerFile指令详解" class="headerlink" title="1.2 DockerFile指令详解"></a>1.2 DockerFile指令详解</h4><ol><li>FROM 指定当前镜像是基于哪个镜像的</li><li>MAINTAINER 镜像维护者的姓名和邮箱地址</li><li>RUN 容器构建时要运行的命令</li><li>EXPOSE 容器启动后对外暴露出的端口</li><li>WORKDIR 指定容器启动后，终端登录进来默认的路径</li><li>ENV 用于在构建镜像的过程中设置环境变量</li><li>ADD 将宿主机中的文件复制到容器并且自动处理URL和tar包解压</li><li>COPY</li><li>VOLUMES 容器数据卷，用于挂载数据卷</li><li>CMD 指定容器启动时要运行的命令，DockerFile中只有最后一个CMD会生效，并且会被run参数替换</li><li>ENTRYPOINT 指定容器启动时候要运行的命令</li><li>ONBUILD 当前镜像被继承时要执行的命令，即父镜像被子镜像继承，子镜像构建时会触发父镜像的ONBUILD指令</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作手册</title>
      <link href="/2022/11/12/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
      <url>/2022/11/12/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="git操作手册"><a href="#git操作手册" class="headerlink" title="git操作手册"></a>git操作手册</h1><p>查看<strong>本地</strong>所有分支</p><p><code>git branch</code></p><p>查看<strong>远程</strong>仓库所有分支</p><p><code>git branch -a</code></p><p>将远程仓库里的指定分支拉取到本地（本地不存在的分支）</p><p><code>git checkout -b 本地分支名 origin/远程分支名</code></p><p>这样在本地会自动创建一个新分支，并与指定的远程分支关联起来，并且会自动切换到该本地分支</p><p>如果出现以下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#x27;dev2&#x27; at the same time.</span><br><span class="line">Did you intend to checkout &#x27;origin/dev2&#x27; which can not be resolved as commit?</span><br></pre></td></tr></table></figure><p>表示拉取不成功，先执行<code>git fetch</code>，再执行上述代码即可</p><p>切换到其他分支</p><p><code>git checkout 分支名</code></p><p>拉取<strong>最新</strong>的信息</p><p><code>git pull</code></p><p>查看其他人的推送记录</p><p><code>git log</code></p><p>提交修改后的文件</p><p><code>git commit -am &#39;提交记录&#39;</code></p><p>将提交推送至远程仓库</p><p><code>git push</code></p><p>为当前仓库设置提交作者的姓名和邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;xxx&quot;</span><br><span class="line">git config user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure><p>将指定分支合并到当前分支</p><p><code>git merge 分支名</code></p><p>删除<strong>远程</strong>分支</p><ol><li>同步远程分支信息 <code>git fetch -p origin</code></li><li>删除对应分支 <code>git push origin --delete 分支名</code></li></ol><p>删除本地分支</p><p><code>git branch -d 分支名</code></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法入门</title>
      <link href="/2022/11/12/Typora%E5%85%A5%E9%97%A8/"/>
      <url>/2022/11/12/Typora%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法入门"><a href="#Markdown语法入门" class="headerlink" title="Markdown语法入门"></a>Markdown语法入门</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题一共有6级，用#和空格实现，标题前面一个#代表一级标题，两个#代表二级标题，以此类推，最多可以加六个#代表六级标题</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>在要强调的内容前后各加两个<em>即表示强调，举例：*<em>这是要强调的内容</em></em></p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>在需要用斜体表示的内容前后各加一个* <em>表示斜体</em></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>在需要删除的内容前后加两个~表示删除，举例：<del>需要删除的内容</del></p><h2 id="list列表处理"><a href="#list列表处理" class="headerlink" title="list列表处理"></a>list列表处理</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>输入数字1和.和空格，自动开始有序列表，shift加Tab退出有序列表</p><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>输入+或-或*和空格，自动开始无序列表</p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><h2 id="Table表格"><a href="#Table表格" class="headerlink" title="Table表格"></a>Table表格</h2><p>Ctrl加T，在弹出的表格中选择行数和列数</p><table><thead><tr><th>value</th><th>value</th><th>value</th></tr></thead><tbody><tr><td>value</td><td>value</td><td>value</td></tr></tbody></table><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>输入三个或三个以上-或*后按回车，即可出现分割线</p><hr><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>直接将图片拖入即可</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[链接提示]+(链接地址)，举例：<a href="https://www.baidu.com/">百度</a></p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>$$加回车<br>$$<br>y &#x3D; 2x ^ 2 + 3x^3;<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>代码的两端各加一个&#96;</p><p>举例：这是一个行内代码   <code>System.out.print(&quot;Hello World!&quot;);</code></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>输入三个~后按回车即可出现代码块编辑器然后选择编程语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h2><p>可以导出pdf或者html格式的文件</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/07/hello-world/"/>
      <url>/2022/11/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
